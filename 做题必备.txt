#pragma GCC optimize(2)
int dt[][2]= {{1,0},{-1,0},{0,1},{0,-1},{0,0}};

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <cmath>
#include <iomanip>
#include <deque>
#include <vector>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <stack>
#include <set>
#include <sstream>
#define rep(i,a,b) for (register int i=(a); i<=(b); i++)
#define per(i,a,b) for (register int i=(a); i>=(b); i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define mod 1000000007
#define eps 1e-6
#define ll long long
#define INF 0x3f3f3f3f
#define MEM(x,y) memset(x,y,sizeof(x))
using namespace std;
int dt[][2]= {{1,0},{-1,0},{0,1},{0,-1},{0,0}};
typedef pair<int, int> P;
//priority_queue<int, vector<int>, greater<int> > q;//小顶堆，即答案按升序排列，q.top是最小的
void optimize_cpp_stdio(){
    std::ios::sync_with_stdio(false);
    std::cout.tie(nullptr);
    std::cin.tie(nullptr);
}
int main(){
    optimize_cpp_stdio();
}
===================================================================
#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <cmath>
#include <iomanip>
#include <deque>
#include <vector>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <stack>
#include <set>
#include <sstream>
#define IOS ios_base::sync_with_stdio(0); cin.tie(0);
#define mod 1000000007
#define eps 1e-6
#define ll long long
#define INF 0x3f3f3f3f
#define MEM(x,y) memset(x,y,sizeof(x))
using namespace std;
int dt[][2]= {{1,0},{-1,0},{0,1},{0,-1},{0,0}};
//typedef pair<int, int> P;
//priority_queue<int, vector<int>, greater<int> > q;
int main(){
    IOS;
}
牛客官方快读：


template<class T>inline void read(T &res)
{
char c;T flag=1;
while((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;res=c-'0';
while((c=getchar())>='0'&&c<='9')res=res*10+c-'0';res*=flag;
}
scanf("%d",&x)  ->  read(x)
cin>>x -> read(x)
===============================
读入优化网友版：
template <typename T> void read (T &x) {
	x = 0; bool f = 1; char ch;
	do {ch = getchar(); if (ch == '-') f = 0;} while (ch > '9' || ch < '0');
	do {x = x * 10 + ch - '0'; ch = getchar();} while (ch >= '0' && ch <= '9');
	x = f ? x : -x;
}

template <typename T> void write (T x) {
	if (x < 0) x = ~x + 1, putchar ('-');
	if (x > 9) write (x / 10);
	putchar (x % 10 + '0');
}
---------------
读入优化：
char getc() {
    static const int L = 1 << 25;
    static char *S, *T, B[L];
    if (S == T) {
        T = (S = B) + fread(B, 1, L, stdin);
        if (S == T)
            return EOF;
    }
    return *(S++);
}
int read() {
    int x = 0;
    char ch;
    while (!isdigit(ch = getc()))
        ;
    while (isdigit(ch)) {
        x = x * 10 + ch - '0';
        ch = getc();
    }

    return x;
}
看个例子就懂用法了：
n = read();
    m = read();
    for (int i = 1; i <= m; ++i) {
        edges[i].u = read();
        edges[i].v = read();
        edges[i].w = read();
    }
-------------------------------------------------
输出优化：
void print(int x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');//输出（要把int型变为char型，加'0'即可）否则不加！！
}
------------------------------------------------------
最大公因数：
int gcd(int a,int b){
    return b==0? a:gcd(b,a % b);
}
==========================================
素数判定：
bool isprim(ll n){
    for(int i=2;i*i<=n;i++){
        if(n%i==0) return false;
    }
    return n!=1;
}


大数素数判定：（Miller_Rabin算法）：

已成功模板：

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int S=5;
ll qpow(ll x,ll k,ll mod){
	ll ret=1;
	while(k){
		if(k&1) ret=(ret*x)%mod;
		x=(x*x)%mod;
		k>>=1;
	}
	return ret;
}

bool miller_rabin(ll n){
	if(n<2) return false;
	if(n==2) return true; // 特判一波
	ll x,pre,u;
	int k=0;
	u=n-1;
	while(!(u&1)){
		k++, u>>=1;
	} // 取2位数
	for(int i=1;i<S;i++){ // 做S次判断
		x=rand()%(n-2)+2; // 随机取(2,n)的数，n若是质数，x肯定与n互质
		x=qpow(x,u,n); // 先算 x^u
		pre=x;
		for(int i=0;i<k;i++){
			x=(x*x)%n; // x^2，二次探测定理
			if(x==1 && pre!=1 && pre!=n-1) return false;
			pre=x;
		}
		if(x%n!=1)return false; // 费马小定理
	}
	return true;
}

int main(){
	ios::sync_with_stdio(false);
	srand(time(0));
	int m;
    ll na;
	cin>>m;
	while(m--){
		cin>>na;
		if(miller_rabin(na)) cout<<"Yes"<<endl;
		else cout<<"No"<<endl;
	}
	return 0;
}

============
以下为没用过的模板。。。

#include<iostream>
#include<stdlib.h>
 
using namespace std;
 
typedef long long ll;
 
//快速积取模 
ll mm(ll a,ll b,ll mod)
{
	ll ans=0;
	while(b)
	{
		if(b&1) ans=(ans+a)%mod;
		a=(a+a)%mod;
		b>>=1;
	}
	return ans;
}
 
//快速幂取模 
ll f(ll x,ll n,ll mod)
{
	ll ans=1;
	while(n)
	{
		if(n&1) ans=mm(ans,x,mod);
		x=mm(x,x,mod);
		n>>=1;
	}
	return ans;
}
 
//Miller-Rabin素数检测算法 
bool miller_rabin(ll n)
{
	if(n==2)
	  return true;
	else if(n==1||n%2==0)
	  return false;
	ll u=n-1,t=0;
	while(u%2==0) u/=2,t++;//n-1=u*2^t 
	for(int i=0;i<10;i++)
	{
		//随机选取一个底数a 
		ll a=rand()%(n-1)+1;
		//计算(a^(n-1))%n=(a^(u*2^t))%n
		
		ll x=f(a,u,n);//先计算(a^u)%n
		for(int j=1;j<=t;j++)//再经过t次循环计算得到 ( (a^u)^(2^t) )%n
		{
			ll y=mm(x,x,n);
			if(y==1&&x!=1&&x!=n-1)//如果不满足二次探测定理，则不是素数 
			  return false;
			x=y;
		}
		if(x!=1) return false;//如果不满足费马小定理，则不是素数 
	 } 
	 return true;//是素数 
}
 
int main()
{
	int t;
	ll n;
	scanf("%d",&t); 
	while(t--)
	{
		scanf("%lld",&n);
		printf("%s\n",miller_rabin(n)?"Yes":"No");
	}
	return 0;
}
==========================================
素数打表：
bool notp[N];
int prime[N], pnum;
void sieve() {//注意！！小n才是你要打的素数表的大小！！！不是大N，大N是小n的数据范围，就是最多打大N那么大的表，一般不用打完！
    memset(notp, 0, sizeof(notp));
    notp[0] = notp[1] = 1;
    pnum = 0;
    for (int i = 2; i <= n; i++) {
        if (!(notp[i])) prime[++pnum] = i;
        for (int j = 1; j <= pnum && prime[j] * i <= n; j++) {
            notp[prime[j] * i] = 1;
            if (i % prime[j] == 0)
                break;
        }
    }
}
================================================
约数枚举：
vector <int> divisor(int n){//注意顺序，如n为12时，vector里是1 12 2 6 3 4  
	vector<int> res;
	for(int i=1;i*i<=n;i++){
		if(n%i==0){
			res.push_back(i);
			if(i!=n/i)res.push_back(n/i);
		}
	}
	return res;
}
==========================================
整数分解：
map<int,int> prime_factor(int n){
	map<int,int>res;
	for(int i=2;i*i<=n;i++){
		while(n%i==0){
			++res[i];
			n/=i;
		}
	}
	if(n!=1)res[n]=1;
	return res;
}
/*int main(){下面不要复制！！！
	map<int,int> k=prime_factor(12);//拿12举例，下面会这样输出        2 2
	for(map<int,int>::iterator it = k.begin();it!=k.end();it++){                3 1   代表12为2^2*3^1; 
		cout<<it->first<<" "<<it->second<<endl;
	}
}*/ 
==========================================
线性筛（欧拉筛）：
int n;
ll num[maxn+1]={1,1},prime[maxn+1]={0},number=0;//如果某个数k是素数，那么num[k]=0,不是素数的为1.
                                                                             //prime这个数组里存的就是我们要的素数们 
for(int i=2;i<=n;++i) 
	{
		if(!num[i])
		  prime[number++]=i;
		for(int j=0;j<number && i*prime[j]<=n;j++)  
        {  
            num[i*prime[j]]=1;                 
            if(!(i%prime[j]))             
                break;  
        }  
    }
=============================================
埃氏筛：
int prime[MAXN];//第i个素数 
bool is_prime[MAXN+1];//is_prime[i]为true表示i是素数
//返回n以内素数的个数
int sieve(int n){
	int p=0;
	for(int i=0;i<=n;i++){
		is_prime[i]=true;
	}
	is_prime[0]=is_prime[1]=false;
	for(int i=2;i<=n;i++){
		if(is_prime[i]){
			prime[p++]=i;
			for(int j=2*i;j<=n;j+=i){
				if_prime[j]=false;
			}
		}
	}
	return p;
} 

=============================================
区间筛法：
//假设是求[a,b)区间上的素数个数 
bool is_prime[MAX_L]//区间长度
bool is_prime_small[MAX_SQRT_B]//用来筛0到根号b的素数
//is_prime[i-a]=true  意义为   i是素数 
void segment_sieve(ll a,ll b){
	for(int i=0;(ll)i*i<b;i++) is_prime_small[i]=true;
	for(int i=0;i<b-a;i++) is_prime[i]=true;
	
	for(int i=2;(ll)i*i<b;i++){
		if(if_prime_small[i]){
			for(int j=2*i;(ll)j*j<b;j+=i) is_prime_small[j]=false;//筛2到根号b 
			for(int j=max(2LL, (a+i-1) / i ) *i ;j<b;j+=i)is_prime[j-a]=false;//筛[a,b) 
		}
	}
}
==================================================
快速幂：
ll qpow(ll x, ll n) {
    ll res = 1;
    x %= mod;
    while (n) {
        if (n & 1) res = res * x % mod;
        x = x * x % mod;
        n >>= 1;
    }
    return res;
}
----------------------------------------------
快速幂取模:

int pow_mod(ll a, ll n, ll m)
{
    long long ans = 1;
    while(n){
        if(n&1){
            ans = (ans * a) % m;
        }
        a = (a * a) % m;
        n >>= 1;
    }
    return ans;
}
============================================
拓展欧几里得算法：
int extgcd(int a,int b,int &x,int &y){
    int d=a;
    if(b!=0){
        d=extgcd(b,a%b,y,x);
        y-=(a/b)*x;
    }
    else {
        x=1;y=0;
    }
    return d;//d是a和b的最大公因数
}
===========================================
背包模板：
int dp[MAX];//存储最后背包最大能存多少
int value[MAX],weight[MAX],number[MAX];//分别存的是物品的价值，每一个的重量以及数量
int bag;
 
void ZeroOnePack(int weight,int value )//01背包
{
    int i;
    for(i = bag; i>=weight; i--)
    {
        dp[i] = max(dp[i],dp[i-weight]+value);
    }
}
void CompletePack(int weight,int value)//完全背包
{
    int i;
    for(i = weight; i<=bag; i++)
    {
        dp[i] = max(dp[i],dp[i-weight]+value);
    }
}
 
void MultiplePack(int weight,int value,int number)//多重背包
{
    if(bag<=number*weight)//如果总容量比这个物品的容量要小，那么这个物品可以直到取完，相当于完全背包
    {
        CompletePack(weight,value);
        return ;
    }
    else//否则就将多重背包转化为01背包
    {
        int k = 1;
        while(k<=number)
        {
            ZeroOnePack(k*weight,k*value);
            number = number-k;
            k = 2*k;//这里采用二进制思想
        }
        ZeroOnePack(number*weight,number*value);
    }
}
==============若是多重背包  就看下面的格式：（其余背包近似）
int main()
{
    int n;
    while(~scanf("%d%d",&bag,&n))
    {
        int i,sum=0;
        for(i = 0; i<n; i++)
        {
            scanf("%d",&number[i]);//输入数量
            scanf("%d",&value[i]);//输入价值  此题没有物品的重量，可以理解为体积和价值相等
        }
        memset(dp,0,sizeof(dp));
        for(i = 0; i<n; i++)
        {
            MultiplePack(value[i],value[i],number[i]);//调用多重背包,注意穿参的时候分别是重量，价值和数量
        }
        cout<<dp[bag]<<endl;
    }
    return 0;
}
===================================
超大背包（可以拿的物品的数量n很少，但是w和v都超大）：
const int maxn=45;
 
int n;
ll w[maxn],v[maxn];
ll W;
 
pair<ll,ll> ps[1<<(maxn/2)];    //(weight,value)
 
void solve(){
    int n2=n/2;
    for(int i=0;i< 1<<n2;i++){
        ll sw=0,sv=0;
        for(int j=0;j<n2;j++){
            if(i>>j&i){
                sw+=w[j];
                sv+=v[j];
            }
        }
        ps[i]=make_pair(sw,sv);
    }
    sort(ps,ps+(1<<n2));
    int m=1;
    for(int i=1;i< 1<<n2;i++){
        if(ps[m-1].second<ps[i].second){
            ps[m++]=ps[i];
        }
    }
    ll res=0;
    for(int i=0;i<(1<<(n-n2));i++){
        ll sw=0,sv=0;
        for(int j=0;j<n-n2;j++){
            if(i>>j&1){
                sw+=w[n2+j];
                sv+=v[n2+j];
            }
        }
        if(sw<W){
            ll tv=(lower_bound(ps,ps+m,make_pair(W-sw,(ll)INF))-1)->second;
            res=max(res,sv+tv);
        }
    }
    printf("%lld\n",res);
}
 
int main(){
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%lld",&w[i]);
    }
    for(int i=0;i<n;i++){
        scanf("%lld",&v[i]);
    }
    scanf("%lld",&W);
    solve();
	return 0;
}

===========================================
洛谷背包：
01：
for(int i=1;i<=n;i++)
{
    for(int c=m;c>=0;c--)
    {
        if(c>=w[i])
        f[c]=max(f[c],f[c-w[i]]+v[i]);
    }
}
----------
完全：
for(int i=1;i<=n;i++)
{
    for(int c=0;c<=m;c++)
    {
        if(c>=w[i])
        f[c]=max(f[c],f[c-w[i]]+v[i]);
    }
}
----------
多重：
for(int i=1;i<=n;i++)
{
    if(w[i]*a[i]>m)
    {
        for(int c=0;c<=m;c++)
        {
        if(c>=w[i])
        f[c]=max(f[c],f[c-w[i]]+v[i]);
        }
    }
    else
    {
         k=1;amount=a[i];
         while(k<amount)
         {
             for(int c=k*w[i];c>=0;c--)
             {
                 if(c>=w[i])
                 f[c]=max(f[c],f[c-w[i]]+k*v[i]);
             }
             amount-=k;
             k<<=1;
         }  
         for(int c=amount*w[i];c>=0;c--)
         {
             f[c]=max(f[c],f[c-w[i]]+amount*v[i]);
         }
    } 
}
===========================================
并查集操作：
void init()//初始化
{
    for(int i=1;i<=n;i++){
        par[i]=i;
        rk[i]=0;
    }
}
int Find(int x)//查找（最好写成非递归的查找方式）
{
    while(x!=par[x])
       x=par[x];
    return x;
}
void unite(int x,int y)//合并
{
    x=Find(x);
    y=Find(y);
    if(x==y)
        return ;
    if(rk[x]<rk[y])
        par[x]=y;
    else{
        par[y]=x;
        if(rk[x]==rk[y])
            rk[x]++;
    }
}
bool same(int x,int y)//判断是否处于一个集合
{
    return Find(x)==Find(y);
}
==========================================
int Scan()
{
    int res=0,ch,flag=0;
    if((ch=getchar())=='-')
        flag=1;
    else if(ch>='0'&&ch<='9')
        res=ch-'0';
    while((ch=getchar())>='0'&&ch<='9')
        res=res*10+ch-'0';
    return flag?-res:res;
}

void Out(LL a)
{
    if(a>9)
        Out(a/10);
    putchar(a%10+'0');
}

=======================================
二叉树之二叉搜索树：（李泽昊学长重点讲的）
    vector<int> tree (1);
    vector<int> depth (1);
    vector<int> parent(1);
    vector<array<int ,2>>child(1);
    auto alloc = [&](int p,int value){
        int new_node = (int)tree.size();
        depth.push_back(depth[p]+1);
        child.push_back({0,0});
        tree.push_back(value);
        parent.push_back(p);
        return new_node;
    };
    auto cmp = [&](int node, int value){
        return tree[node] < value;
    };
    auto insert = [&](int value){
        if(tree.size() == 1)
            alloc(0,value);
        else{
            int pointer=1;
            int direction;
            for(;;){
                direction = cmp(pointer,value);
                if(child[pointer][direction] == 0)
                    break;
                pointer = child[pointer][direction];
            }
            int new_node = alloc(pointer,value);
            child[pointer][direction]= new_node;
        }
    };
    auto find = [&](int value){
        if(tree.size() == 1)
            return 0;
        int pointer = 1;
        while(pointer != 0 && tree[pointer] != value){
            int direction = cmp(pointer,value);
            pointer=child[pointer][direction];
        }
        return pointer;
    };
====================================================================
=============================================
floyd：

int N,M,W;
int S,E,T;
int d[Maxn][Maxn];
void init()
{
    //i到j的距离为INF
    MEM(d,INF);
    for(int i=1; i<=N; i++)//自己到自己的距离为0
        d[i][i]=0;
}
bool Floyd()//Floyd算法求最短路
{
    int i,j,k;
    for(k=1; k<=N; k++)
    {
        for(i=1; i<=N; i++)
        {
            for(j=1; j<=N; j++)
            {
                if(d[i][j]>d[i][k]+d[k][j])//（用min会超时）
                    d[i][j]=d[i][k]+d[k][j];
            }
            if(d[i][i]<0)//转了一圈，回到这里时，时间为负数，则回到她出发之前的某个时间
                return 1;
        }
    }
    return 0;
}
上面这个floyd模板可以判断是否存在负环，存在则返回1，不存在返回零
或者：

int graph[maxn][maxn];
void floyd(int n)
{
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n;++j)
		{
			for(int k=1;k<=n;++k)
			{
				graph[j][k]=min(graph[j][k],graph[j][i]+graph[i][k]);
			}
		}
	}
}
void init(int n)
{
	memset(graph,inf,sizeof(graph));
	for(int i=1;i<=n;++i)
	{
		graph[i][i]=0;
	}
}
int main(){
                                                  /初始化并赋权值后再floyd(n);/           
    ///例如POJ2139中：https://blog.csdn.net/liuke19950717/article/details/51126524\\\
                                init(n);
		for(int i=0;i<m;++i)
		{
			int tp,num[305]={0};
			scanf("%d",&tp);
			for(int j=0;j<tp;++j)
			{
				scanf("%d",&num[j]);
			}
			for(int j=0;j<tp;++j)
			{
				for(int k=j+1;k<tp;++k)
				{
					graph[num[j]][num[k]]=graph[num[k]][num[j]]=1;
				}
			}
		}
		floyd(n);
}
   又例如这个虫洞，即找有无负环：https://www.cnblogs.com/sky-stars/p/11347515.html
我们一定要学习他们是如何赋权值的！！！赋权值的过程就是建图的过程，各种算法是改图的过程！！！！！！
=======================================================
floyd操作模板：
#include<cstdio>
#include<iostream>
#include <bits/stdc++.h>
using namespace std;
#define MAX 500
#define INFE 1<<20
 
int N; 
int mp[MAX][MAX],b[MAX],path[MAX][MAX];  //path[i][j]记录路径
 
void init()
{
       int i,j;
       for(i=1;i<=N;i++)
              for(j=1;j<=N;j++)
              {
                     mp[i][j]=INFE;
                     path[i][j]=j;
              }
}
 
void floyd()
{
       int i,j,k;
       for(k=1;k<=N;k++)
              for(i=1;i<=N;i++)
                     for(j=1;j<=N;j++)
                            if(mp[i][j]>mp[i][k]+mp[k][j])
                            {
                                   mp[i][j]=mp[i][k]+mp[k][j];
                                   path[i][j]=path[i][k];
                            }
}
 
 
int main()
{
       int m,u,v,len;
       while(scanf("%d%d",&N,&m)!=EOF) //输入城市数量 和 道路数量
       {
              init();//初始化
              while(m--)
              {
                     scanf("%d%d%d",&u,&v,&len);
                     mp[u][v]=mp[v][u]=len;
              }
              floyd();//进行每对节点的求最小路径
              
              while(scanf("%d%d",&u,&v))
              {//输入起点和终点
                     int tmp=u;
                     printf("%d",u);
                     while(tmp!=v)
                     {//打印路径
                            printf("-->%d",path[tmp][v]);
                            tmp=path[tmp][v];
                     }
					 //输出最小花费
                     cout<<endl;
                     cout<<"cost: "<<mp[u][v]<<endl;
              }
       }
       return 0;
}
==========================================================
普通bellman-ford:这里有一点很好就是这个函数是bool型的，可以用来判断有无负环！
#include <iostream>
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=2e4+10;
const ll inf=2147483647;
struct E
{
    int v,w;
};
vector<E> edge[maxn];
ll dis[maxn];//dis[i]代表i这个点到定点的最短路
bool bellman(int s,int n)
{
    for (int i=1; i<=n; i++)
        dis[i]=inf;
    dis[s]=0;
    for (int k=1; k<=n;k++)
    for (int i=1; i<=n; i++)
    {
        for (int j=0; j<edge[i].size();j++)
        {
            ll v=edge[i][j].v,w=edge[i][j].w;
            if (dis[v]>dis[i]+w)
                dis[v]=dis[i]+w;
        }
    }
    for (int i=1; i<=n; i++)
    {
        for (int j=0; j<edge[i].size();j++)
        {
            int v=edge[i][j].v,w=edge[i][j].w;
            if (dis[v]>dis[i]+w)
                return 1;
        }
    }
    return 0;
}
int main()
{
    int n,m,s;
    scanf("%d%d%d",&n,&m,&s);
    for (int i=1; i<=m; i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        edge[u].push_back({v,w});
    }
    int flag=bellman(s,n);
    for (int i=1; i<=n-1; i++)
    {
        printf("%lld ",dis[i]);
    }
    printf("%lld\n",dis[n]);
　　 flag ? cout<<"Yes\n" : cout<<"No\n";
    return 0;
}
========================================================================
优化bellman-ford算法：
#include <iostream>
#include <bits/stdc++.h>
 
using namespace std;
struct E
{
    int v,w;
};
const int maxn=2e4+10,inf=1e9+7;
vector <E> edge[maxn];
int in[maxn],dis[maxn];
void SPFA(int s,int n)
{
    for (int i=1;i<=n;i++) dis[i]=inf;
    dis[s]=0;
    queue <int> Q;
    Q.push(s);
    in[s]=1;
    while(!Q.empty())
    {
        int cur=Q.front();
        Q.pop();
        in[cur]=0;
        int num=edge[cur].size();
        for (int i=0; i<num; i++)
        {
            int v=edge[cur][i].v,w=edge[cur][i].w;
            if (dis[v]>dis[cur]+w)
            {
                dis[v]=dis[cur]+w;
                if (!in[v])
                    Q.push(v),in[v]=1;
            }
        }
    }
}
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for (int i=1; i<=m; i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        edge[u].push_back({v,w});
    }
    SPFA(1,n);
    for (int i=2;i<=n;i++)
    {
        printf("%d\n",dis[i]);
    }
    return 0;
}
=============================================================
优化dij算法1：d[i][j]表示顶点i和顶点j的最短距离（好用！）
const int manx=1e3+5;//顶点个数的最大范围
const int mamx=1e6+5;//边数的最大范围（最多有几条路，可以看）
struct node{
    int v,next,w;
}a[mamx];
int d[manx][manx],head[manx];
bool vis[manx];
int n,m,s,e,k=0;
void add(int u,int v,int w)
{
    a[++k].next=head[u];
    head[u]=k;
    a[k].v=v;
    a[k].w=w;
}
void dij()
{
    for(int i=1;i<=n;i++) d[s][i]=1e9;
    memset(vis,0,sizeof(vis));
    priority_queue<pair<int,int> >q;
    d[s][s]=0;
    q.push(make_pair(0,s));
    while(q.size()){
        int u=q.top().second;
        q.pop();
        if(vis[u]) continue;
        vis[u]=1;
        for(int i=head[u];i;i=a[i].next)
        {
            int v=a[i].v,w=a[i].w;
            if(d[s][v]>d[s][u]+w)
                d[s][v]=d[s][u]+w,q.push(make_pair(-d[s][v],v));
        }
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&e);
    for(int i=1;i<=m;i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w);
        add(v,u,w);//若是单向的则去掉这句
    }
    for(int i=1;i<=n;i++) s=i,dij();//再往下，要用到某个点i到某个点j的最短距离   就直接d[i][j]
}
================================================
优化Dijstra算法2：
#include <iostream>
#include <bits/stdc++.h>
using namespace std;
const int maxn=5e6+10;
const int inf=INT_MAX/2;
/*struct E
{
    int v,w;
    bool operator< (const E& b) const
    {
        return w > b.w;
    }
};*/
struct E
{
    int v,w;
    friend bool operator< (E x,E y)
    {
        return x.w>y.w;
    }
    //重载<运算符，使得距离小的优先级大
};
/*struct cmp
{
    bool operator() (const E &x,const E &y) const
    {
        return x.w>y.w;
    }
};*/
int vis[maxn],dis[maxn];
vector <E> edge[maxn];
int dijheap(int s,int e,int n)
{
    priority_queue <E> Q;
    for (int i=0; i<=n; i++)
        dis[i]=inf;
    Q.push({s,0});
    dis[s]=0;
    while(!Q.empty())
    {
        E cur=Q.top();//保证取出的队首元素就是距离s最近的
        Q.pop();
        int cv=cur.v;
        if (vis[cv]) continue;
        vis[cv]=1;
        int num=edge[cv].size();
        for (int i=0;i<num;i++)//用这个点去扩展relax
        {
            int v=edge[cv][i].v,w=edge[cv][i].w;
            if (!vis[v])
            {
                if (dis[v]>dis[cv]+w)
                {
                    dis[v]=dis[cv]+w;
                    Q.push({v,dis[v]});
                }
            }
        }
    }
    return dis[e];
}

int main()
{
    int n,m,t;
    scanf("%d%d%d",&n,&m,&t);
    for (int i=1; i<=m; i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        edge[u].push_back({v,w});
        edge[v].push_back({u,w});
    }
    int ans=dijheap(1,t,n);
    printf("%d\n",ans);
    return 0;
}
==========================================
dij3:
李泽昊学长的multimap法  依然很优化：

vector<int> dijkstra(int s,vector<vector<pair<int,int>>>& G){
	vector<multimap<int,int>::iterator> position(G.size());
	multimap<int,int> tree;
	vector<int> dis(G.size());
	for(int i=0;i<(int)G.size();i++){
		dis[i]=i==s?0:INF;
		position[i]=tree.emplace(dis[i],i);
	}
	while(!tree.empty()){
		int node =tree.begin->second;
		tree.erase(tree.begin());
		for(auto&& it : G[node]){
			if(dis[node]+it.second<dis[it.first]){
				dis[it.first]=dis[node]+it.second;
				tree.erase(position[it.first]);
				position[it.first]=tree.emp;ace(dis[it.first],it.first);
			}
		}
	}
	return dis;
}
===========================================================
kuangbin的dij模板：（s是起点，d[i]表示从起点到i点的最短距离）(好用！)
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
const int inf=2147483647;
const int manx=1e4+5; //与n相对，对应顶点的个数
const int mamx=5e5+5; //与m相对，对应边的个数
priority_queue< pair<int,int> >q; 
struct node{ 
    int next,v,w;//就是u,v,w
}edge[mamx];  //边去mamx，其余取manx
bool vis[manx];  //这里的标记数组与spfa的vis数组含义不同，这里标记是否入过队列
int head[manx],d[manx],cnt[manx];
int k=0;
int n,m,s,e; //s作为起点，e作为终点
void add(int u,int v, int w) //链式前向星存图
{
    edge[++k].next=head[u];
    edge[k].v=v;
    edge[k].w=w;
    head[u]=k;
}
void dijkstra()
{
    for(int i=1;i<=n;i++) //初始化vis d 数组
        d[i]=inf,vis[i]=0;
    d[s]=0; //s作为起点
    q.push(make_pair(0,s));
    while(q.size()){
        int x=q.top().second; //取出队头
        q.pop();
        if(vis[x]) continue; //如果点x访问过，跳过，访问下一个队头
        vis[x]=1; //访问x做标记
        for(int i=head[x];i;i=edge[i].next){
            int v=edge[i].v,w=edge[i].w;
            if(d[v]>d[x]+w){ //松弛操作，更新距离
                d[v]=d[x]+w;
                q.push(make_pair(-d[v],v)); //把更新的距离和点入队，这里距离取负变成小根堆
            }
            else if(d[v]==d[x]+w)//两条路相等，说明这个顶点存在另外一条最短路，让cnt[v]=1，标记一下，代表存在。
                   cnt[v]=1;//如果有时候需要用到求有几条相等的最短路的时候，这里可以++，而不是仅仅等于1，这也是我开int而不是bool的目的
        }
    }
}
int main()
{
    cin>>n>>m>>s;
    for(int i=1;i<=m;i++){
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w);//一定要注意这里！！！如果反向建图（s等于终点），除了让s=终点，还要u到v的路是add(v,u,w)!!!!!!反过来了！！！
        //无向图  add(v,u,w);
    }
    s=1;
    dijkstra();
    for(int i=1;i<=n;i++)
        printf("%d ",d[i]);
    return 0;
}
   /*边的遍历：
    在遍历以x为起点的所有边时，只需要这样就行：
   for(int i=head[x];i;i=edge[i].next)*/
=========================================================
除了要求距离以外，加一个求钱数的条件，优先最短距离，最短距离相等时选用钱数少的（说不定以后除了最短距离以外让还求个什么东西呢）
sum数组用来存储两个点间的最少钱数，（思路是：若遍历到一个新路，且这条路比原来的路短，无条件选他，即使造价高也没事，但若和
原来的路的距离相等，这个时候我们就要最少的造假钱数，用sum数组存储），此外这个板子，用的二维数组d[i][j]，
可以求出i到j的最短距离，虽然在这没什么用，但是用以后肯定用的到，这个可以直接拿来用
#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <cmath>
#include <deque>
#include <vector>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <stack>
#include <set>
#include <sstream>
#define IOS ios_base::sync_with_stdio(0); cin.tie(0)
#define Mod 1000000007
#define eps 1e-6
#define ll long long
#define INF 0x3f3f3f3f
#define MEM(x,y) memset(x,y,sizeof(x))
#define Maxn 20000+5
#define P pair<int,int>//first最短路径second顶点编号
using namespace std;
int N,M;
struct edge
{
    int to,dis,cost;
    edge(int to,int dis,int cost):to(to),dis(dis),cost(cost) {}
};
vector<edge>G[Maxn];//G[i] 从i到G[i].to的距离为dis，花费的钱为cost
int d[Maxn][Maxn];//d[i][j]从i到j的最短距离
int sum[Maxn];//sum[i]，起点到i之间所需要的花费的钱
void Dijk(int s)
{
    priority_queue<P,vector<P>,greater<P> >q;//按first从小到大出队
    for(int i=0; i<=N; i++)
        d[s][i]=INF;
    d[s][s]=0;
    q.push(P(0,s));
    while(!q.empty())
    {
        P p=q.top();
        q.pop();
        int v=p.second;//点v
        if(d[s][v]<p.first)
            continue;
        for(int i=0; i<G[v].size(); i++)
        {
            edge e=G[v][i];//枚举与v相邻的点
            if(d[s][e.to]>=d[s][v]+e.dis)
            {
                if(d[s][e.to]==d[s][v]+e.dis)//距离相等，比较谁花费的钱少
                    sum[e.to]=min(sum[e.to],e.cost);
                else//若d[s][e.to]>d[s][v]+e.dis，相求出最短距离，再求出最短距离所需要的钱
                    sum[e.to]=e.cost;
                d[s][e.to]=d[s][v]+e.dis;
                q.push(P(d[s][e.to],e.to));
            }
        }
    }
}
int main()
{
    IOS;
    while(cin>>N>>M,N+M)
    {
        MEM(sum,0);
        for(int i=1; i<=N; i++)
            G[i].clear();
        for(int i=0; i<M; i++)
        {
            int u,v,d,c;
            cin>>u>>v>>d>>c;
            G[u].push_back(edge(v,d,c));
            G[v].push_back(edge(u,d,c));
        }
        Dijk(1);//城市1到各个城市的最短距离
        int ans=0;
        for(int i=2; i<=N; i++)
            ans+=sum[i];
        cout<<ans<<endl;
    }
    return 0;
}
==========================================================
用Dijstra算法倒序输出最短路径：
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const int maxn=1e3+20;
const int inf=1e9+7;
int dis[maxn],vis[maxn],pre[maxn];
struct E
{
    int v,w;
    bool friend operator< (E x,E y)
    {
        return x.w>y.w;
    }
};
vector <E> edge[maxn];
void dij(int s,int n)
{
    priority_queue <E> Q;
    while(Q.size()) Q.pop();
    for (int i=1; i<=n; i++)
        dis[i]=inf;
    dis[s]=0;pre[s]=s;
    Q.push({s,0});
    while(!Q.empty())
    {
        E cur=Q.top();
        Q.pop();
        int cv=cur.v;
        int num=edge[cv].size();
        if (vis[cv]) continue;
        vis[cv]=1;
        for (int i=0; i<num; i++)
        {
            int v=edge[cv][i].v,w=edge[cv][i].w;
            if (dis[v]>dis[cv]+w)
            {
                dis[v]=dis[cv]+w;
                Q.push({v,dis[v]});
                pre[v]=cv;
            }
        }
    }
}
void outway(int i)
{
    if (pre[i]!=i)
    {
        printf("%d-->",i);
        outway(pre[i]);
    }
    else printf("1\n");
    return ;
}
/*void callway(int i,int x)//若要正序输出用这个
{
    while(pre[i]!=i)
    {
        way[x].push(i);
        i=pre[i];
    }
    way[x].push(1);
}
void outway(int x)
{
   while(way[x].size())
   {
       int a=way[x].top();
       way[x].pop();
       if (way[x].size()==0)
            printf("%d\n",a);
       else
        printf("%d-->",a);
   }
}

for (int i=2; i<=n; i++)
            callway(i,i),outway(i);*/
int main()
{
    int n,m;
    freopen("out2.txt","w",stdout);
    while(~scanf("%d%d",&n,&m))
    {
        if (n==0&&m==0) break;
        memset(vis,0,sizeof(vis));
        memset(edge,0,sizeof(edge));
        memset(pre,0,sizeof(pre));
        for (int i=1; i<=m; i++)
        {
            int u,v,w,flag=0;
            scanf("%d%d%d",&u,&v,&w);
            edge[u].push_back({v,w});
        }
        dij(1,n);
        for (int i=2; i<=n; i++)
            i==n ? printf("%d\n",dis[i]) :printf("%d ",dis[i]);
        for (int i=2; i<=n; i++)
            outway(i);
    }
    return 0;
}
==========================================================
次短路：
typedef pair<int, int> P;
int N,R;
struct edge{ int to,cost;};
vector<edge> G[5050];
int dist1[5050];
int dist2[5050];
void solve(){
    priority_queue <P,vector<P>,greater<P> >que;
    fill(dist1,dist1+N,INF);
    fill(dist2,dist2+N,INF);
    dist1[0] = 0;
    que.push(P(0,0));
    while(!que.empty()){
        P p=que.top();que.pop();
        int v=p.second,d=p.first;
        if(dist2[v]<d)continue;
        for(int i=0;i<G[v].size();i++){
            edge &e=G[v][i];
            int d2=d+e.cost;
            if(dist1[e.to]>d2){
                swap(dist1[e.to],d2);
                que.push(P(dist1[e.to],e.to));
            }
            if(dist2[e.to]>d2&&dist1[e.to]<d2){
                dist2[e.to]=d2;
                que.push(P(dist2[e.to],e.to));
            }
        }
    }
    cout << dist2[N-1]<<endl;
}
int main(){
    int a,b,c;
    while(cin>>N>>R){
        for(int i=0;i<N;i++)G[i].clear();
        for(int i=0;i<R;i++){
            cin>>a>>b>>c;
            a--;b--;
            G[a].push_back(edge{b,c});
            G[b].push_back(edge{a,c});
        }solve();
    }

}
=====================================================
稀疏图用Kruskal,  稠密图用Prim,建议先拿前者试一下
Kruskal:
#include<iostream> 
#include<algorithm>
#include<cstdio>
using namespace std;
const int manx=1e5+5; //对应顶点数目
const int mamx=1e5+5; //对应边的数目
int n,m,u,v,total=1;
struct edge{
    int start,to;
    long long val;
}bian[mamx];
int a[manx];
long long ans;
int find(int x) //并查集
{
    if(a[x]==x) return x;
    else return a[x]=find(a[x]);
}
bool cmp(edge x,edge y)
{
    return x.val<y.val;//若要最大生成树，这里改为>即可
}
inline void kruskal()
{
    for(int i=1;i<=m;i++)
    {
        u=find(bian[i].start);
        v=find(bian[i].to);
        if(u==v) continue; //如果两个点存在于同一个集合则跳过循环
        ans+=bian[i].val;
        a[u]=v;
        total++;
        if(total==n) break;
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    ans=0;total=1;//别忘更新，掉过坑
    for(int i=1;i<=n;i++) //并查集的初始化，祖先为自己
        a[i]=i; 
    for(int i=1;i<=m;i++)
        scanf("%d%d%d",&bian[i].start,&bian[i].to,&bian[i].val);
    sort(bian+1,bian+1+m,cmp);
    kruskal();
    cout<<ans;
    return 0;
   /*if(total==n)cout<<ans<<endl;
    else cout<<-1<<endl;*/    //这里可以用来判断能否生成一个树  无法生成就输出-1
}
=============
Prim:
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int manx=5e3+5;
const int mamx=1e5+5;
int k,n,m,cnt,sum,a,b,c;
int head[manx],dis[manx],vis[manx];
struct node{
    int v,w,next;
}e[mamx];
typedef pair<int,int> p;
priority_queue<p,vector<p>,greater<p> >q; //堆优化
void add(int u, int v, int w) //链式前向星建图
{
    e[++k].v=v;
    e[k].w=w;
    e[k].next=head[u];
    head[u]=k;
}
int main()
{
    memset(dis,127,sizeof(dis));
    memset(head,-1,sizeof(head));
    scanf("%d%d",&n,&m);
    for(R i=1;i<=m;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
      //无向图   add(b,a,c);
    }
    dis[1]=0; //一般将1作为最小生成树扩展的起点
    q.push(make_pair(0,1));
    while(!q.empty() && cnt<n)  //仔细观察可以发现堆优化的Prim也和堆优化的Dij的代码实现有很多相似之处，这是因为两者都是基于贪心的算法
    {
        int d=q.top().first,u=q.top().second;
        q.pop();
        if(vis[u]) continue;
        cnt++;  //计算S集合中顶点的个数
        sum+=d;  //计算最小权值和
        vis[u]=1; 
        for(R i=head[u];i;i=e[i].next)
            if(e[i].w<dis[e[i].v])
                dis[e[i].v]=e[i].w,q.push(make_pair(dis[e[i].v],e[i].v));
    }
    printf("%d",sum);
}
======================================================
找最小生成树的个数（Kruskal+Matrix_Tree定理）：
/*
 *算法引入：
 *给定一个含有N个结点M条边的无向图,求它最小生成树的个数t(G);
 *
 *算法思想：
 *抛开“最小”的限制不看,如果只要求求出所有生成树的个数,是可以利用Matrix-Tree定理解决的;
 *Matrix-Tree定理此定理利用图的Kirchhoff矩阵,可以在O(N3)时间内求出生成树的个数;
 *
 *kruskal算法：
 *将图G={V,E}中的所有边按照长度由小到大进行排序,等长的边可以按照任意顺序;
 *初始化图G’为{V,Ø},从前向后扫描排序后的边,如果扫描到的边e在G’中连接了两个相异的连通块,则将它插入G’中;
 *最后得到的图G’就是图G的最小生成树;
 *
 *由于kruskal按照任意顺序对等长的边进行排序,则应该将所有长度为L0的边的处理当作一个阶段来整体看待;
 *令kruskal处理完这一个阶段后得到的图为G0,如果按照不同的顺序对等长的边进行排序,得到的G0也是不同;
 *虽然G0可以随排序方式的不同而不同,但它们的连通性都是一样的,都和F0的连通性相同(F0表示插入所有长度为L0的边后形成的图);
 *
 *在kruskal算法中的任意时刻,并不需要关注G’的具体形态,而只要关注各个点的连通性如何(一般是用并查集表示);
 *所以只要在扫描进行完第一阶段后点的连通性和F0相同,且是通过最小代价到达这一状态的,接下去都能找到最小生成树;
 *
 *经过上面的分析,可以看出第一个阶段和后面的工作是完全独立的;
 *第一阶段需要完成的任务是使G0的连通性和F0一样,且只能使用最小的代价;
 *计算出这一阶段的方案数,再乘上完成后续事情的方案数,就是最终答案;
 *
 *由于在第一个阶段中,选出的边数是一定的,所有边的长又都为L0;
 *所以无论第一个阶段如何进行代价都是一样的,那么只需要计算方案数就行了;
 *此时Matrix-Tree定理就可以派上用场了,只需对F0中的每一个连通块求生成树个数再相乘即可;
 *
 *Matrix-Tree定理:
 *G的所有不同的生成树的个数等于其Kirchhoff矩阵C[G]任何一个n-1阶主子式的行列式的绝对值；
 *n-1阶主子式就是对于r(1≤r≤n),将C[G]的第r行,第r列同时去掉后得到的新矩阵,用Cr[G]表示;
 *
 *算法举例：
 *HDU4408(Minimum Spanning Tree)
 *
 *题目地址：
 *http://acm.hdu.edu.cn/showproblem.php?pid=4408
 *
 *题目大意：
 *给定一个含有N个结点M条边的无向图,求它最小生成树的个数,所得结果对p取模;
**/
 
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<queue>
#include<algorithm>
#include<vector>
using namespace std;
 
const int N=111;
const int M=1111;
 
typedef __int64 LL;
 
struct Edges
{
    int a,b,c;
    bool operator<(const Edges & x)const
    {
        return c<x.c;
    }
} edge[M];
 
int n,m;
int mod;
LL f[N],U[N],vist[N];//f,U都是并查集，U是每组边临时使用
LL G[N][N],C[N][N];//G顶点之间的关系，C为生成树计数用的Kirchhoff矩阵
 
vector<int>V[N];//记录每个连通分量
 
int Find(int x,LL f[])
{
    if(x==f[x])
        return x;
    else
        return Find(f[x],f);
}
 
LL det(LL a[][N],int n)//生成树计数:Matrix-Tree定理
{
    for(int i=0; i<n; i++)
        for(int j=0; j<n; j++)
            a[i][j]%=mod;
    int ret=1;
    for(int i=1; i<n; i++)
    {
        for(int j=i+1; j<n; j++)
            while(a[j][i])
            {
                int t=a[i][i]/a[j][i];
                for(int k=i; k<n; k++)
                    a[i][k]=(a[i][k]-a[j][k]*t)%mod;
                for(int k=i; k<n; k++)
                    swap(a[i][k],a[j][k]);
                ret=-ret;
            }
        if(a[i][i]==0)
            return 0;
        ret=ret*a[i][i]%mod;
    }
    return (ret+mod)%mod;
}
 
void Solve()
{
    sort(edge,edge+m);//按权值排序
    for(int i=1; i<=n; i++)//初始化并查集
    {
        f[i]=i;
        vist[i]=0;
    }
 
    LL Edge=-1;//记录相同的权值的边
    LL ans=1;
    for(int k=0; k<=m; k++)
    {
        if(edge[k].c!=Edge||k==m)//一组相等的边,即权值都为Edge的边加完
        {
            for(int i=1; i<=n; i++)
            {
                if(vist[i])
                {
                    LL u=Find(i,U);
                    V[u].push_back(i);
                    vist[i]=0;
                }
            }
            for(int i=1; i<=n; i++) //枚举每个连通分量
            {
                if(V[i].size()>1)
                {
                    for(int a=1; a<=n; a++)
                        for(int b=1; b<=n; b++)
                            C[a][b]=0;
                    int len=V[i].size();
                    for(int a=0; a<len; a++) //构建Kirchhoff矩阵C
                        for(int b=a+1; b<len; b++)
                        {
                            int a1=V[i][a];
                            int b1=V[i][b];
                            C[a][b]=(C[b][a]-=G[a1][b1]);
                            C[a][a]+=G[a1][b1];//连通分量的度
                            C[b][b]+=G[a1][b1];
                        }
                    LL ret=(LL)det(C,len);
                    ans=(ans*ret)%mod;//对V中的每一个连通块求生成树个数再相乘
                    for(int a=0; a<len; a++)
                        f[V[i][a]]=i;
                }
            }
            for(int i=1; i<=n; i++)
            {
                U[i]=f[i]=Find(i,f);
                V[i].clear();
            }
            if(k==m)
                break;
            Edge=edge[k].c;
        }
 
        int a=edge[k].a;
        int b=edge[k].b;
        int a1=Find(a,f);
        int b1=Find(b,f);
        if(a1==b1)
            continue;
        vist[a1]=vist[b1]=1;
        U[Find(a1,U)]=Find(b1,U);//并查集操作
        G[a1][b1]++;
        G[b1][a1]++;
    }
 
    int flag=0;
    for(int i=2; i<=n&&!flag; i++)
        if(U[i]!=U[i-1])
            flag=1;
    if(m==0)
        flag=1;
    printf("%I64d\n",flag?0:ans%mod);
 
}
 
int main()
{
    //freopen("C:\\Users\\Administrator\\Desktop\\kd.txt","r",stdin);
    while(scanf("%d%d%d",&n,&m,&mod),n+m+mod)
    {
        memset(G,0,sizeof(G));
        for(int i=1; i<=n; i++)
            V[i].clear();
        for(int i=0; i<m; i++)
            scanf("%d%d%d",&edge[i].a,&edge[i].b,&edge[i].c);
        Solve();
    }
    return 0;
}
==========================================================
二分模板：（除了下面两种模板以外，其实还有一种思路：while里写r-l>1,然后每次没有什么mid+1或者mid-1或者ans，最后L就是对的值。）
//最大化最小值：
int l=0,r=?;
int ans=1;
while(l<=r){
    int mid=(l+r)>>1;
    if(check(mid)){
        l=mid+1;
        ans=mid;
    }
    else r=mid-1;
}
cout<<ans<<endl;
--------------------------
//最小化最大值:
int l=0,r=?;
int ans=1;
while(l<=r){
    int mid=(l+r)>>1;
    if(check(mid)){
        r=mid-1;
        ans=mid;
    }
    else l=mid+1;
}
    cout<<ans<<endl;
--------------------------
有相同的时候输出最左边的那个：
int searchRange(vector<int>& nums, int target) {
        int l=0,r=nums.size()-1;
        while(l<r){
            int mid=l+r>>1;
            if(check(mid))r=mid;
            else l=mid+1;
        }
    return l;
}
-----------------------------
有相同的时输出最右边的那个：
int searchRange(vector<int>& nums, int target) {
        int l=0,r=nums.size()-1;
        while(l<r){
            int mid=l+r+1>>1;
            if(check(mid))l=mid;
            else r=mid-1;
        }
    return l;
}
=========================================================
三分模板（这个是带精度的，不带精度的  直接int或者longlong就行）
自己的：
开口向下的，求最大值：
double ans;
double l=?,r=?;
for(int i=0;i<？？？;i++){//估计一下，看需要三分几次才能找到单峰函数的最值
    double lm=l+(r-l)/3,rm=r-(r-l)/3;
    if(value(lm)>=value(rm)){//如果开口向上，求最小值，只需要这里改成<=
        r=rm;
        ans=value(rm);
    }
    else
        l=lm;
}
    cout<<fixed<<setprecision(?)<<ans<<endl;

别人的好板子：（不妨先用这个）

const double EPS=1e-10;
double calc(double n)//不一定只有一个参数
{
    return   ;//需要自己按实际情况填写
}
double solve(double L,double R)
{
    double M,RM;
    while(L+EPS<R)
    {
        M=(L+R)/2;
        RM=(M+R)/2;
        if(calc(M)<calc(RM))//计算最小值 最大值改符号就行！！！
            R=RM;
        else
            L=M;
    }
    return L或者calc(L);//如果要输出横坐标，就L，要输出值，就calc（L）；
}
=====================================================
线段树：（其实如何建树是很重要的，下面是按照和来建树的，也就是两个子节点的和等于父节点）
其实下面这个模板有个不好的地方，他没有写pushup函数，作为模板来看确实不合格（当然，写法是很优秀的，只是作为使用者来说不方便修改），pushup函数就是建树方式，
比如这里用求和建树的pushup函数就是让两个子节点的和等于父节点：
函数为：void PushUp(int k){Sum[k]=Sum[k<<1]+Sum[k<<1|1];}  
这里我举个例子，你看下面build函数最后一行，直接写的tree[k].w=tree[k*2].w+tree[k*2+1].w;
其实作为模板，不如先写个pushup函数，到时候下面这一行直接用pushup（k）来代替即可，便于适用于不同题目
比如题目让求最小值怎么建树呢，这个时候其实只需要改一下pushup函数:
void pushup(int k){tree[i] = min(tree[i << 1], tree[i << 1 | 1]);}不就很方便吗。。。
快忘了上面这段话啥意思的时候比对这两个网站的模板：

https://blog.csdn.net/qq_41268623/article/details/81713198（求和建树）
https://blog.csdn.net/waterboy_cj/article/details/81532163（求区间最大值最小值）

我就是比对这两个网站的模板才理解的。
下面我也会贴，但是一定要打开两个网站同时比对着看！！！比对有上面不同，进而理解我上面写的那段话


所以下面这个模板用来初学者参考着理解就行了（用来学习的），真要做题的话，还是用写一个pushup来的方便
在这个彩色气球背景网站的模板下面，我会贴出更方便的模板，但是功能上可能只是一部分，具体用到我会再搜的。


彩色气球背景的那个网站的线段树模板：（https://www.cnblogs.com/TheRoadToTheGold/p/6254255.html）
建树：
struct node
{
       int l,r,w;//l，r分别表示区间左右端点，w表示区间和
}tree[4*n+1];
void build(int l,int r,int k)//l,r是区间，k是编号（注意是tree数组的下标，所谓数据结构就是把一个数组的各个下标连成某种关系）
{
    tree[k].l=l;tree[k].r=r;
    if(l==r)//叶子节点 
    {
        scanf("%d",&tree[k].w);
        return ; 
    }
    int m=(l+r)/2;
    build(l,m,k*2);//左孩子 
    build(m+1,r,k*2+1);//右孩子 
    tree[k].w=tree[k*2].w+tree[k*2+1].w;//状态合并，此结点的w=两个孩子的w之和 //pushup（k）。
}

单点查询：（即查询一个点的状态，设待查询点为x，如果没有查到返回ans=0.。。maybe??待我填坑回来修改再确定）

void ask(int k)//从第k号节点开始查
{
    if(tree[k].l==tree[k].r) //当前结点的左右端点相等，是叶子节点，是最终答案 
    {
        ans=tree[k].w;
        return ;
    }
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) ask(k*2);//目标位置比中点靠左，就递归左孩子 
    else ask(k*2+1);//反之，递归右孩子 
}

单点修改，即更改某一个点的状态。用引例中的例子，对第x个数加上y（当然，也可以进行其他加/减/更新为另一个数等操作）
void add(int k)
{
    if(tree[k].l==tree[k].r)//找到目标位置 
    {
        tree[k].w+=y;
        //tree[k].w=y;
        return;
    }
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) add(k*2);
    else add(k*2+1);
    tree[k].w=tree[k*2].w+tree[k*2+1].w;//所有包含结点k的结点状态更新 
}

区间查询，即查询一段区间的状态，在引例中为查询区间[x,y]的和

void sum(int k)
{
    if(tree[k].l>=x&&tree[k].r<=y) 
    {
        ans+=tree[k].w;
        return;
    }
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) sum(k*2);
    if(y>m) sum(k*2+1);
}

区间修改，即修改一段连续区间的值，我们已给区间[a,b]的每个数都加x为例

void down(int k)//这一步是下传f（lazy标记）
{
    tree[k*2].f+=tree[k].f;
    tree[k*2+1].f+=tree[k].f;
    tree[k*2].w+=tree[k].f*(tree[k*2].r-tree[k*2].l+1);
    tree[k*2+1].w+=tree[k].f*(tree[k*2+1].r-tree[k*2+1].l+1);
    tree[k].f=0;
}
void add(int k)//这一步是修改
{
    if(tree[k].l>=a&&tree[k].r<=b)//当前区间全部对要修改的区间有用 
    {
        tree[k].w+=(tree[k].r-tree[k].l+1)*x;//(r-1)+1区间点的总数
        tree[k].f+=x;//x就是你要更改的，也可以赋值啊，求sqrt啊都可。如tree[k].f=sqrt(tree[])
        return;
    }
    if(tree[k].f) down(k);//懒标记下传。只有不满足上面的if条件才执行，所以一定会用到当前节点的子节点 
    int m=(tree[k].l+tree[k].r)/2;
    if(a<=m) add(k*2);
    if(b>m) add(k*2+1);
    tree[k].w=tree[k*2].w+tree[k*2+1].w;//更改区间状态 
}

Ⅳ.懒标记的引入对其他基本操作的影响

     因为引入了懒标记，很多用不着的更改状态存了起来，这就会对区间查询、单点查询造成一定的影响。

     所以在使用了懒标记的程序中，单点查询、区间查询也要像区间修改那样，对用得到的懒标记下传。其实就是加上一句if(tree[k].f)  down（k），其余不变。
具体看下面总的代码的每一步，跟上面有什么区别，其实就是在return下面加了一句if(tree[k].f)  down（k）


总模板代码：
#include<cstdio>
using namespace std;
int n,p,a,b,m,x,y,ans;
struct node
{
    int l,r,w,f;
}tree[400001];
inline void build(int k,int ll,int rr)//建树 
{
    tree[k].l=ll,tree[k].r=rr;
    if(tree[k].l==tree[k].r)
    {
        scanf("%d",&tree[k].w);
        return;
    }
    int m=(ll+rr)/2;
    build(k*2,ll,m);
    build(k*2+1,m+1,rr);
    tree[k].w=tree[k*2].w+tree[k*2+1].w;
}
inline void down(int k)//标记下传 
{
    tree[k*2].f+=tree[k].f;
    tree[k*2+1].f+=tree[k].f;
    tree[k*2].w+=tree[k].f*(tree[k*2].r-tree[k*2].l+1);
    tree[k*2+1].w+=tree[k].f*(tree[k*2+1].r-tree[k*2+1].l+1);
    tree[k].f=0;
}
inline void ask_point(int k)//单点查询
{
    if(tree[k].l==tree[k].r)
    {
        ans=tree[k].w;
        return ;
    }
    if(tree[k].f) down(k);
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) ask_point(k*2);
    else ask_point(k*2+1);
}
inline void change_point(int k)//单点修改 
{
    if(tree[k].l==tree[k].r)
    {
        tree[k].w+=y;
        return;
    }
    if(tree[k].f) down(k);
    int m=(tree[k].l+tree[k].r)/2;
    if(x<=m) change_point(k*2);
    else change_point(k*2+1);
    tree[k].w=tree[k*2].w+tree[k*2+1].w; //pushup[k]
}
inline void ask_interval(int k)//区间查询 
{
    if(tree[k].l>=a&&tree[k].r<=b) 
    {
        ans+=tree[k].w;
        return;
    }
    if(tree[k].f) down(k);
    int m=(tree[k].l+tree[k].r)/2;
    if(a<=m) ask_interval(k*2);
    if(b>m) ask_interval(k*2+1);
}
inline void change_interval(int k)//区间修改 
{
    if(tree[k].l>=a&&tree[k].r<=b)
    {
        tree[k].w+=(tree[k].r-tree[k].l+1)*y;
        tree[k].f+=y;
        return;
    }
    if(tree[k].f) down(k);
    int m=(tree[k].l+tree[k].r)/2;
    if(a<=m) change_interval(k*2);
    if(b>m) change_interval(k*2+1);
    tree[k].w=tree[k*2].w+tree[k*2+1].w;//pushup[k]
}
int main()
{
    scanf("%d",&n);//n个节点 
    build(1,1,n);//建树 
    scanf("%d",&m);//m种操作 
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&p);
        ans=0;
        if(p==1)
        {
            scanf("%d",&x);
            ask_point(1);//单点查询,输出第x个数 
            printf("%d",ans);
        } 
        else if(p==2)
        {
            scanf("%d%d",&x,&y);
            change_point(1);//单点修改 
        }
        else if(p==3)
        {
            scanf("%d%d",&a,&b);//区间查询 
            ask_interval(1);
            printf("%d\n",ans);
        }
        else
        {
             scanf("%d%d%d",&a,&b,&y);//区间修改 
             change_interval(1);
        }
    }
}
==================================
下面还是用来学习的模板，就是上面提到的那两个网站的模板：
线段树求区间最小值（内含改值小功能）：
//问最小值
//Q a b 询问(a,b)中最小值！！！
//C a b 将a点值改为b！！！！
#include <bits/stdc++.h>
using namespace std;
#define maxn 200005
 
int min(int a, int b)
{
	return a>b ? b : a;
}
int tree[4 * maxn];
 
void pushup(int i)
{
	tree[i] = min(tree[i << 1], tree[i << 1 | 1]);//由于这里我们要的只是一个最小值，就不用结构体了，这一点对比DAY9的F.cpp 与 https://blog.csdn.net/waterboy_cj/article/details/81532163（感悟多存个区间其实。。想存就存hhh，存了咱就用，不存咱也能传值过来只不过多俩参数（我现在的理解是这样的，不知道是否有误，以后水平高了来勘误） ），对于一个节点如果要存的东西多的话再用结构体，比如说彩色气球网站里那个模板，我们用结构体存了每一个节点的左区间和右区间，以及对应原数组在这个区间的和。
}
void build(int i, int l, int r)
{
	if (l == r)
	{
		scanf("%lld", &tree[i]);
		return;
	}
	int mid = (l + r) / 2;
	build(i << 1, l, mid);
	build(i << 1 | 1, mid + 1, r);
	pushup(i);
}
 
void update(int i, int l, int r, int x, int val)
{
	if (l == r)///l==x²»±ØÒª
	{
		tree[i] = val;
		return;
	}
	int mid = (l + r) / 2;
	if (x <= mid) update(i << 1, l, mid, x, val);
	else update(i << 1 | 1, mid + 1, r, x, val);
	pushup(i);
}
 
int query(int i, int l, int r, int x, int y)
{
	if (x <= l && r <= y)
		return tree[i];
	int minn = 9999999;
	int mid = (l + r) / 2;
	if (x <= mid) minn = min(minn, query(i << 1, l, mid, x, y));//每次递归，要找的目标没变，即求[x,y]区间的
	if (y>mid) minn = min(minn, query(i << 1 | 1, mid + 1, r, x, y));
	return minn;
}
 
int main()//主函数里的一定要好好理解，看是如何使用上面的函数的
{
	int n, m;
	int b, c;
	char a;
	while (scanf("%d%d", &n, &m) != -1)
	{
		build(1, 1, n);
		while (m--)
		{
			scanf(" %c%d%d", &a, &b, &c);
			if (a == 'Q')
				printf("%d\n", query(1, 1, n, b, c));//意思就是：我从第一号节点开始查，区间呢，我是让L=1,R=n，(如果有结构体，就是我们存的一个节点里保存的小区间，而我们这里没有用结构体，但也能实现，就是写的函数多了两个参数，这里是从第一号节点开始的，所以是L=1.R=n,另外看上面的query函数怎么递归的，这就是省略结构体的写法，咱们把结构体省了怎么知道每个节点的左右区间呢，答案是直接给他传过去！如何传呢，写函数多俩参数不就好了，递归的时候也是直接把子节点的左右区间放在了函数里，当然，如果有结构体呢，写函数就可以少俩参数，都一样的)
			else
				update(1, 1, n, b, c);
		}
	}
	return 0;
}
-----------------------
求区间最大值：
#include <bits/stdc++.h>
using namespace std;
#define maxn 200005
int tree[4 * maxn];
 
void pushup(int i)
{
	tree[i] = max(tree[i << 1], tree[i << 1 | 1]);
}
 
void build(int i, int l, int r)
{
	if (l == r)
	{
		tree[i] = 0;
		return;
	}
	int mid = (l + r) / 2;
	build(i << 1, l, mid);
	build(i << 1 | 1, mid + 1, r);
	pushup(i);
}
 
void update(int i, int l, int r, int x, int val)
{
	if (l == r)
	{
		tree[i] = val;
		return;
	}
	int mid = (l + r) / 2;
	if (x <= mid) update(i << 1, l, mid, x, val);
	else update(i << 1 | 1, mid + 1, r, x, val);
	pushup(i);
}
 
int query(int i, int l, int r, int x, int y)
{
	if (x <= l && r <= y)
		return tree[i];
	int maxm = 0;
	int mid = (l + r) / 2;
	if (x <= mid) maxm = max(maxm, query(i << 1, l, mid, x, y));
	if (y>mid) maxm = max(maxm, query(i << 1 | 1, mid + 1, r, x, y));
	return maxm;
}
 
int main()
{
	int n, m;
	int b, c;
	char a;
	while (~scanf("%d%d", &n, &m))
	{
		build(1, 1, n);
		while (m--)
		{
			scanf(" %c%d%d", &a, &b, &c);
			if (a == 'Q')
				printf("%d\n", query(1, 1, n, b, c));
			else
				update(1, 1, n, b, c);
		}
	}
}
-------------------------------------

结构体版本，结构体版本就比较方便，可以同时求最大值和最小值！！！：
struct node
{
	int maxx;
	int minn;
	int l;
	int r;
};
int maxx,minn;
const int MAXN=5e4+10;
int h[MAXN];
node tree[200010];
void build(int l,int r,int root)
{
	tree[root].l=l;
	tree[root].r=r;
	if(l==r)
	{
		tree[root].maxx=h[l];//这里我是用h数组存下来了，因为我要同时求最大值和最小值，便于赋值，平时只求最大或者最小或者求和啊上面的赋值一个式子就够了的情况下，可以不存到数组里，直接在这里cin>>tree[root].
		tree[root].minn=h[l];
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,root*2);
	build(mid+1,r,root*2+1);
	tree[root].maxx=max(tree[2*root].maxx,tree[2*root+1].maxx);
	tree[root].minn=min(tree[2*root].minn,tree[2*root+1].minn);
}

void findmax(int l,int r,int root)//l,r,是你要查询的区间，就是在这里面找最大最小值的
{
	if(tree[root].l==l&&tree[root].r==r)//如果某个节点所保存的区间刚好是你想求的区间
	{                                //注意这里改成if(l<=tree[root].l&&r>=tree[root].r)return tree[root].max也对！！
		if(tree[root].maxx>maxx)
			maxx=tree[root].maxx;
		return;
	}
	int mid=(tree[root].l+tree[root].r)>>1;//将节点二分，一半是[l,mid],一半是（mid,r],
	if(mid>=r)//如果你要查询的区间，r比mid小，，那就往左儿子走
		findmax(l,r,root*2);
	else if(mid<l)//如果你要查询的区间，l比mid大，那就往右儿子走
		findmax(l,r,root*2+1);
	else//如果这个节点保存的区间的mid在你要查询的区间中间插着，往左走则漏了右边的要查询的区间，往右走则漏了左边要查询的区间，那么我们就两个都走！递归下去的时候总会转化成上面某种情况的，最差也只是到叶子节点
	{
		findmax(l,mid,root*2);
		findmax(mid+1,r,root*2+1);
	}
}

void findmin(int l,int r,int root)
{
	if(tree[root].l==l&&tree[root].r==r)
	{
		if(tree[root].minn<minn)
			minn=tree[root].minn;
		return;
	}
	int mid=(tree[root].l+tree[root].r)>>1;
	if(mid>=r)
		findmin(l,r,root*2);
	else if(mid<l)
		findmin(l,r,root*2+1);
	else
	{
		findmin(l,mid,root*2);
		findmin(mid+1,r,root*2+1);
	}
}

int main()
{
	int n,q,i,a,b;
	scanf("%d%d",&n,&q);
	for(i=1;i<=n;i++)
		scanf("%d",&h[i]);
	build(1,n,1);
	while(q--)
	{
		maxx=0;
		minn=99999999;
		scanf("%d%d",&a,&b);
		findmax(a,b,1);
		findmin(a,b,1);
		printf("%d\n",maxx-minn);
	}
	return 0;
}
=====================================
再回到求和版本的线段树：这次功能还没彩色气球版本多，但却是一个优秀的模板，因为修改及其容易，看着也舒服了很多，如果一些简单操作可以用一下这种写法：
#define maxn 100007  //元素总个数  
int Sum[maxn<<2];//Sum求和，开四倍空间
int A[maxn],n;//存原数组下标[1，n]
//建树
 
//PushUp函数更新节点信息，这里是求和
void PushUp(int rt){Sum[rt]=Sum[rt<<1]+Sum[rt<<1|1];}  
//Build函数建立线段树
void Build(int l,int r,int rt){ //[l,r]表示当前节点区间，rt表示当前节点的实际存储位置 
    if(l==r) {//若到达叶节点 
        Sum[rt]=A[l];//存储A数组的值
        return;  
    }  
    int m=(l+r)>>1;  
   //左右递归
    Build(l,m,rt<<1);  
    Build(m+1,r,rt<<1|1);  
    //更新信息
    PushUp(rt);  
}  
//点修改
 
void Update(int L,int C,int l,int r,int rt){//[l,r]表示当前区间，rt是当前节点编号//l,r表示当前节点区间，rt表示当前节点编号  
    if(l==r){//到达叶节点，修改叶节点的值
        Sum[rt]+=C;  //这里也可以赋值啊，求sqrt啊什么的都可以，改一下这句话就行了，其他啥也不用改！！！！很方便吧
        return;  
    }  
    int m=(l+r)>>1;  
   //根据条件判断往左子树调用还是往右
    if(L <= m) Update(L,C,l,m,rt<<1);  
    else       Update(L,C,m+1,r,rt<<1|1);  
    PushUp(rt);//子节点的信息更新了，所以本节点也要更新信息
}   
//区间查询（这儿为求和，上面那个板子是求最小值，注意对比看这点不同是如何实现的！！！） 
 
int Query(int L,int R,int l,int r,int rt){//[L,R]表示操作区间，[l,r]表示当前区间，rt:当前节点编号
    if(L <= l && r <= R){  
       //在区间内直接返回
        return Sum[rt];  
    }  
    int m=(l+r)>>1;  
    //左子区间:[l,m] 右子区间：[m+1,r]  求和区间:[L,R]
   //累加答案
    int ANS=0;  
    if(L <= m) ANS+=Query(L,R,l,m,rt<<1);//左子区间与[L,R]有重叠，递归
    if(R >  m) ANS+=Query(L,R,m+1,r,rt<<1|1); //右子区间与[L,R]有重叠，递归
    return ANS;  
} 
//区间修改
void update(int root, int l, int r, int ql, int qr)//ql和qr是你要修改的区间，比如这个就是把[ql,qr]这个区间的所有值开根号
{
    if(l == r)
        sum[root] = sqrt(sum[root]);
    else if(ql <= l && qr >= r && sum[root] == r - l + 1)
        ;
    else {
        int mid = (l + r) >> 1;
        if(ql <= mid)
            update(root << 1, l, mid, ql, qr);
        if(qr > mid)
            update((root << 1) + 1, mid + 1, r, ql, qr);
        pushup(root);
    }
}

======================================================
求最长上升子序列：（求最长不下降子序列的话就改为upper_bound...）
int dp[MAX_N];
void solve(){
	fill(dp,dp+n,INF);
	for(int i=0;i<n;i++){
		*lower_bound(dp,dp+n,a[i])=a[i];
	}
	cout<<lower_bound(dp,dp+n,INF)-dp<<endl;
} 
=======================================================
atcoder上的一道题，就是map<string,int> mp,对于他，优先对value值排序，value值相等时再按key的字典序排序：
主要学习是如何将map放到vector上来排序，这里用到了pair  因为map都是两个参数，要想让vector也这样，最好用pair
题目链接：https://atcoder.jp/contests/abc155/tasks/abc155_c
代码：
#include <bits/stdc++.h>
using namespace std;
typedef pair<string , int> p;
const int N=2e5+10;
map<string,int>mp;
bool cmp(const p &left,const p &right){//注意这里，是如何写cmp函数的
    if(left.second==right.second)
    return left.first<right.first;
    return left.second>right.second;
}
int main(){
    int n;
    cin >> n;
    for(int i=0;i<n;i++){
       string a;
        cin >> a;
        mp[a]++;
    }
    vector <p> vec(mp.begin(),mp.end());//注意这里，是如何将map存进vector的
    sort(vec.begin(),vec.end(),cmp);
    int cnt=1;
    for(vector<p>::iterator ite=vec.begin();ite!=vec.end()-1;++ite){
        if(ite->second==(ite+1)->second){
            cnt++;
        }
        else{
            break;
        }
    }
    for(int i=0;i<cnt;i++){
        cout<<vec[i].first<<endl;
    }
}
==============================================
最大流和最小费用最大流：
下面是模板，模板题对应https://loj.ac/problem/102
模板来源：https://loj.ac/submission/745203
#include <bits/stdc++.h>
#define sz(v) (int)v.size()
#define v(x) vector<x>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;

const int MAXN = 10001;
const int MAXM = 100001;
const int INF = 0x7fffffff;

/* MCMF_zzq
 *
 * 调用：
 *     init(n) 初始化
 *     addEdge(u, v, cap, cost) 建图
 *     solve(s, t) 计算答案
 *     cost - 费用， flow - 流量
 */

struct MCMF {
    int N, M, S, T;
    int flow, ans, sum;

    v(int) G[MAXN];
    int dist[MAXN], cap[MAXM], cost[MAXM], to[MAXM];
    bool aug[MAXN];

    void _add_edge(int a, int b, int c, int d) { G[a].push_back(++M), to[M] = b, cap[M] = c, cost[M] = d; }

    // u, v, capacity, cost
    void add_edge(int a, int b, int c, int d) { _add_edge(a, b, c, d), _add_edge(b, a, 0, -d); }

    int dfs(int u, int lim) {
        if (!lim)
            return 0;
        if (u == T)
            return ans += lim * sum, lim;
        int f = 0, v;
        aug[u] = true;
        for (auto e : G[u])
            if (!cost[e] && cap[e] && !aug[v = to[e]]) {
                int t = dfs(v, std::min(lim - f, cap[e]));
                cap[e] -= t, cap[e ^ 1] += t, f += t;
                if (f == lim)
                    break;
            }
        if (f == lim)
            aug[u] = false;
        return f;
    }

    bool augment() {
        std::priority_queue<pii, std::vector<pii>, std::greater<>> q;
        std::fill(dist, dist + N + 1, INF);
        q.push({ dist[T] = 0, T });
        while (!q.empty()) {
            pii x = q.top();
            q.pop();
            if (dist[x.second] != x.first)
                continue;
            int &u = x.second, dt, v;
            for (int e : G[u])
                if (cap[e ^ 1] && (dt = dist[u] - cost[e]) < dist[v = to[e]])
                    q.push({ dist[v] = dt, v });
        }
        sum += dist[S];
        for (int i = 0; i <= N; ++i)
            for (int e : G[i]) cost[e] += dist[to[e]] - dist[i];
        return dist[S] != INF;
    }

    void init(int n) {
        N = n, M = 1;
        for (int i = 0; i <= n; ++i) G[i].clear();
    }

    void solve(int _s, int _t) {
        int res;
        S = _s, T = _t;
        flow = ans = sum = 0;
        do
            do
                std::fill(aug, aug + N + 1, 0);
            while (flow += (res = dfs(S, INF)), res > 0);
        while (augment());
    }
} mcmf;

int main() {
    int n, m;
    cin >> n >> m;
    mcmf.init(n);//这里初始化千万不要忘记
    for (int i = 0; i < m; i++) {
        int u, v, c, w;
        cin >> u >> v >> c >> w;
        mcmf.add_edge(u, v, c, w);
    }
    mcmf.solve(1, n);//这里注意是（1，n）
    cout << mcmf.flow << " " << mcmf.ans;
}
======================================
dinic算最大流：（注意flow其实最好开longlong，防止爆int，可以先试试int能不能过  不能过再开longlong吧）
两种模型：https://vjudge.net/contest/357230#problem/A  （这个是需要外加源点和汇点的）
                 https://loj.ac/problem/101      （这个是最裸的模板题，就是直接连的，啥也不用加，下面有备注）
#define SZ(v) (int)v.size()

const int INF = 1e9;
const int MAXN = 1010;
const int MAXM = 1e5 + 10;

namespace MaxFlow {
    struct Edge {
        int v, rev, f;
    };

    int n, s, t;
    int cur[MAXM], dep[MAXN], gap[MAXN];
    int flow;
    std::vector<Edge> G[MAXN];

    void add_edge(int u, int v, int f) {
        G[u].push_back({v, SZ(G[v]), f});
        G[v].push_back({u, SZ(G[u]) - 1, 0});
    }

    int dfs(int u, int lim) {
        if (u == t) return lim;
        int num = 0, f;
        for (int &i = cur[u], v; i < SZ(G[u]); ++i) {
            if (dep[v = G[u][i].v] == dep[u] - 1 && (f = G[u][i].f))
                if (G[u][i].f -= (f = dfs(v, std::min(lim - num, f))),
                        G[v][G[u][i].rev].f += f, (num += f) == lim)
                    return num;
        }
        if (!--gap[dep[u]++]) dep[s] = n + 1;
        return ++gap[dep[u]], cur[u] = 0, num;
    }

    void init(int _n) {
        n = _n;
        for (int i = 0; i < n; ++i) G[i].clear();
    }

    void solve(int _s, int _t) {
        s = _s, t = _t, flow = 0;
        for (int i = 0; i <= n; ++i) cur[i] = dep[i] = gap[i] = 0;
        for (gap[0] = n; dep[s] <= n; flow += dfs(s, INF));
    }
}

using MaxFlow::add_edge;
int main() {
    // 这个板子 0 点不能用，下标必须从 1 开始（就是 0 不能做节点编号，节点要从1开始标号）
    int n, m, s, t;
    scanf("%d%d", &n, &m);
    s = n + n + 1, t = n + n + 2;//如果给了s 和 t的编号呢，我们就直接输入就行了，而且最下面那个for就可以没有了  ，而这里这个题呢我们是相当于给本题目2n个点外面又加了一个总源点s和一个总的汇点t，所以把2n+1,2n+2,作为他们的编号
    MaxFlow::init(n + n + 2);
    for (int i = 0, x, y; i < m; ++i) {
        scanf("%d%d", &x, &y);
        add_edge(x, y + n, 1);
    }
    for (int i = 1; i <= n; ++i) add_edge(s, i, 1), add_edge(i + n, t, 1);//如果不用外连汇点，我们就无需这个循环了。
    MaxFlow::solve(s, t);
    printf("%d\n", MaxFlow::flow);
    return 0;
}
/*
int main() {//这是最裸的
    int n,m,s,t;
    cin>>n>>m>>s>>t;
    MaxFlow::init(n);
    for(int i=0,x,y,z;i<m;i++){
        cin>>x>>y>>z;
        add_edge(x,y,z);
    }
    MaxFlow::solve(s,t);
    printf("%lld\n",MaxFlow::flow);
}           */
================================================
最大流模板2：
const int MAX = 1010
const int inf = 522133279;
const int mod = 1000000007;

int F,D,N;
int g[MAX][MAX];
int lv[MAX];

bool bfs(int src , int tar)
{
    clr(lv,0);
    queue<int> que;
    que.push(src);
    lv[src]=1;

    while(!que.empty())
    {
        int cur = que.front(); que.pop();

        for(int i = src ; i <= tar ; i++)
            if(!lv[i] && g[cur][i])
            {
                lv[i]=lv[cur]+1;
                if(i == tar) return 1;
                que.push(i);
            }
    }
    return 0;
}

int dfs(int cur , int src , int tar , int totflow)
{
    int ret=0;
    if(cur==tar||!totflow)
        return totflow;

    for(int i = src ; i <= tar ; i++)
    {
        if(totflow==0) break;
        if(g[cur][i]&&lv[cur]+1==lv[i])
        {
            int f = min(totflow,g[cur][i]);
            int flowdown = dfs(i,src,tar,f);
            ret+=flowdown;
            totflow-=flowdown;
            g[cur][i]-=flowdown;
            g[i][cur]+=flowdown;
        }
    }
    return ret;
}

int dinic(int src , int tar)
{
    int ret=0;
    while(bfs(src,tar))
    {
        int tmp = dfs(src,src,tar,D+F);
        if(!tmp) break;
        ret += tmp;
    }
    return ret;
}
此模板连边示例：g[u][v]=c   代表u和v这俩点之间连一条容量为c的边
算结果示例：cout<<dinic(s,t).
===============================
算二分图最大匹配：（匈牙利算法）  模板题见--（HDU 2063 过山车）。
main函数里每使用一次一定要MEM（）一下，也就是一定要清空！！！
匈牙利1（很方便万能）：

#define MAX_V 500 + 16
int V;                 // 顶点数
vector<int> G[MAX_V];    // 图的邻接表
int match[MAX_V];      // 所匹配的顶点
bool used[MAX_V];      // DFS中用到的访问标记
 
// 向图中增加一条连接u和v的边
void add_edge(int u, int v)
{
	G[u].push_back(v);
	G[v].push_back(u);
}
 
// 通过DFS寻找增广路
bool dfs(int v)
{
	used[v] = true;
	for (vector<int>::iterator it = G[v].begin(); it != G[v].end(); ++it)
	{
		int u = *it, w = match[u];
		if (w < 0 || !used[w] && dfs(w))
		{
			match[v] = u;
			match[u] = v;
			return true;
		}
	}
 
	return false;
}
 
// 求解二分图的最大匹配
int bipartite_matching()
{
	int res = 0;
	memset(match, -1, sizeof(match));
	for (int v = 0; v < V; ++v)
	{
		if (match[v] < 0)
		{
			memset(used, 0, sizeof(used));
			if (dfs(v))
			{
				++res;
			}
		}
	}
 
	return res;
}
 
void clear()
{
	for (int i = 0; i < V; ++i)
	{
		G[i].clear();
	}
}
--------------------------------------------------------------
匈牙利2：（https://www.cnblogs.com/wangdongkai/p/5635684.html）
/* ***************************************************
二分图匹配（匈牙利算法的DFS实现）
INIT：G[][]两边定点划分的情况
CALL:res=Hungary();输出最大匹配数
优点：适于稠密图，DFS找增广路快，实现简洁易于理解
时间复杂度:O(VE);
*************************************************** */
const int MAXN = 510;
int uN,vN;//u,v数目
int G[MAXN][MAXN];//编号是1~n的//初始化为0，两者之间有边则赋值为1
int linker[MAXN];
bool used[MAXN];

bool dfs(int u)
{
    int v;
    for(v=1;v<=vN;v++){
        if(G[u][v]&&!used[v]){
            used[v]=true;
            if(linker[v]==-1||dfs(linker[v])){
                linker[v]=u;
                return true;
            }
        }
    }
    return false;
}

int Hungary()
{
    int res=0;
    int u;
    memset(linker,-1,sizeof(linker));
    for(u=1;u<=uN;u++){
        memset(used,false,sizeof(used));
        if(dfs(u)) res++;
    }
    return res;
}
===============================================
erase函数配合unique函数达到去重的效果：(注意使用unique函数之前要sort一下)
比如我要对vector<int> vec去重：
sort(vec.begin(),vec.end());
vec.erase(unique(vec.begin(),vec.end()),vec.end());//这是因为unique函数的返回值是一个迭代器，它指向的是去重后容器中不重复序列的最后一个元素的下一个元素。
==================================================
排列组合（组合数）：
算C n m:
int comb(int n,int m){
     if(n-m<m)m=n-m;
     if(m==0)return 1;
     return comb(n-1,m-1)*n/m;
}
------------------
算A n m:
int a[13]={1,1};
	for(int i=2;i<13;i++){
		a[i]=a[i-1]*i;
	}
	int n,m;
	while(cin>>n>>m){
		cout<<a[n]/a[n-m]<<endl;
	}
--------------------
超快求C n m:(常用)(主函数别忘了每次使用要init())
ll qpow(ll a,ll x){
    ll ret=1;
    while (x){
        if (x&1)
            ret = ret*a%mod;
        a=a*a%mod;
        x>>=1;
    }
    return ret;
}
ll fac[maxn],inv[maxn];
ll init(){
    fac[0]=1;
    for (int i=1;i<maxn;i++)
        fac[i]=fac[i-1]*i%mod;
    inv[maxn-1]=qpow(fac[maxn-1],mod-2);
    for (int i=maxn-2;i>=0;i--)
        inv[i]=inv[i+1]*(i+1)%mod;
    return 0;
}
ll c(ll n,ll m){
    return fac[n]*inv[m]%mod*inv[n-m]%mod;
}
==========================
卢卡斯求C n m:(注意卢卡斯算出来的C的值是已经模好的C，也就是返回的是C n m %mod)
当需要模的数大于1e5时(如1e9+7)：
typedef long long ll;

const int N = 1e9 ;
const int P = 1e8 + 7;

ll quickPower(ll a, ll b) {
    ll res = 1;
    a %= P;
    while (b) {
        if (b & 1)res = (res % P) * (a % P) % P;
        a = (a % P) * (a % P) % P;
        b >>= 1;
    }
    return res;
}
ll inv(ll x) {//x关于p的逆元，p为素数
    return quickPower(x, P - 2);
}
ll C(ll n, ll m) {
    if (m > n)return 0;
    ll up = 1, down = 1;//分子分母;
    for (int i = n - m + 1; i <= n; i++)
        up = up * i % P;
    for (int i = 1; i <= m; i++)
        down = down * i % P;
    return up * inv(down) % P;
}
ll Lucas(ll n, ll m) {
    if (m == 0)return 1;
    return C(n % P, m % P) * Lucas(n / P, m / P) % P;
}
------------------------
当需要模的数比较小时：
typedef long long ll;
const int N = 1e5 ;
const int P = 99991;//取一个小于N的素数
ll fact[P + 5], inv[P + 5], Finv[P + 5];//阶乘打表

void init() {
    inv[1] = 1;
    //线性递推求逆元
    for (int i = 2; i <= P; i++) {
        inv[i] = (P - P / i) * 1ll * inv[P % i] % P;
    }
    fact[0] = Finv[0] = 1;
    for (int i = 1; i < P; i++) {
        fact[i] = fact[i - 1] * 1ll * i % P;//求阶乘
        Finv[i] = Finv[i - 1] * 1ll * inv[i] % P;//求阶乘的逆元
    }
}
 
ll C(ll n, ll m){//组合数C(n, m) % p
    if (m > n)return 0;
    return fact[n] * Finv[n - m] % P * Finv[m] % P;
}
ll Lucas(ll n, ll m){
    return m ? C(n % P, m % P) * Lucas(n / P, m / P) % P : 1;
}
=======================================
求数列11212312345.。。。第k个数字是哪一个数字：
ll q,k;
ll check(ll a , ll b ){
    ll sum=0;
    for(ll i=1;i<=a;i*=10){
        if(b==1)
        sum+=(a-i+1)*(a-i+2)/2;
        else 
        sum+=a-i+1;
    }
    return sum;
}
ll find(ll l,ll r,ll p){
    while(r-l>1){
        ll mid=(l+r)/2;
        if(check(mid,p)>=k){
            r=mid;
        }
        else
        {
            l=mid;
        }
        
    }
    return l;
}
int main(){
    IOS;
    cin>>q;
    while(q--){
        cin>>k;
        ll x=find(0,1e9,1);
        k-=check(x,1);
        ll y=find(0,x+1,0);
        k-=check(y,0);
        char num[201];
        sprintf(num,"%lld",y+1);
        cout<<num[k-1]<<endl;
    }
}
==================================
十转k进制：
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

void TentoAny(LL num,int k)//十进制数转化为 k进制(2<=k<=36)
{
	vector<char> v;//不定长数组
	LL t;//余数 
	while(num)
	{
		t=num%k;
		if(t>=10)v.push_back((char)('A'+t-10));//向尾部添加元素
		else v.push_back((char)(t+'0'));
		num/=k;
	}
	for(int i=v.size()-1;i>=0;i--)//先算出来的余数最后输出（逆序列）
		cout<<v[i];
	cout<<endl;
}
int main()
{
	LL n;
	int k;
	cin>>n>>k;
	TentoAny(n,k);
	return 0;
}
=====================================
map按照value排序，当value相等时，按照key值排序：
typedef pair<string , int> p;//< >里都是可以改的，但是要和map对应哦
map<string,int>mp;
bool cmp(const p &left,const p &right){//写好比较函数
    if(left.second==right.second)
    return left.first<right.first;
    return left.second>right.second;
    。。。。。
    vector <p> vec(mp.begin(),mp.end());//申请一个vector，讲map传入，注意必须是再申请vector的时候才能这样子传
    sort(vec.begin(),vec.end(),cmp);//按照cmp排序
  。。。。。
    for(vector<p>::iterator ite=vec.begin();ite!=vec.end()-1;++ite)//之后就可以开始遍历了；
也能写成：for(auto it=vec.begin();it!=vec.end();++it)//这是C++11的标准
==========================================
n*n数独编号：
设他的编号是x，则 行数：row=(x-1)/n+1;   列数：col=(x-1)%4+1;   小块编号：(row-1)/2*2+(col-1)/2+1;
==========================================
矩阵快速幂求斐波那契第n项,F(n)%mod。（1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, ...）
//本题为矩阵快速幂求斐波那契
//n的值要用long long型 
#include<stdio.h>
typedef long long LL;
 
int mod=1000000009; //m为要取模的数 
 
struct matrix
{
	LL map[10][10];
}a,per; //a是要自乘的2*2的矩阵，per是2*2的单位矩阵 
 
void init()
{ //初始化函数 
	a.map[0][0]=1;
	a.map[0][1]=1;
	a.map[1][0]=1;
	a.map[1][1]=0;
	int i,j;
	for(i=0;i<2;i++) //单位矩阵对角线为1，其他为0 
		for(j=0;j<2;j++)
			per.map[i][j]=(i==j);
} 
 
matrix multi(matrix a,matrix b)
{ //两个矩阵a、b相乘 
	matrix c;
	int i,j,k;
	for(i=0;i<2;i++)
		for(j=0;j<2;j++)
		{
			c.map[i][j]=0;
			for(k=0;k<2;k++) c.map[i][j]+=(a.map[i][k]*b.map[k][j])%mod;
			c.map[i][j]%=mod;			
		}
	return c;
}
 
matrix power(LL k)
{ //矩阵快速幂 
	matrix p,ans;
	ans=per; 
	p=a;
	while(k)
	{
		if(k&1) ans=multi(ans,p);
		p=multi(p,p);
		k/=2;
	}
	return ans;
}
 
int main()
{
	int i;
	LL n;
	matrix ans;	
	while(~scanf("%lld",&n))
	{		
		init();
		ans=power(n-1);
		printf("%lld\n",ans.map[0][0]);
	}
	return 0;
}
======================================
欧拉函数（欧拉函数是小于或等于n的正整数中与n互质的数的数目）（例如φ(8)=4，因为1,3,5,7均和8互质。）
LL eulr(LL n)
 {
     LL ans=n;
     for(LL i=2;i*i<=n;i++)
     {   
        if(n%i==0)
         {   
             ans=ans/i*(i-1);
             while(n%i==0)
                 n/=i;
         }
     }
     if(n>1)
         ans=ans/n*(n-1);
     return ans;
}
================================
群论给矩阵染色问题：
？？？
================================
CF大神版本的快速幂（pw函数）和组合数(cnk函数)和加减乘除取模函数
#include <bits/stdc++.h>
using namespace std;
typedef long double ld;
typedef long long ll;
const int mod = 998244353;
 
const int root = 646;
 
const int root_1 = 208611436;
 
const int root_pw = 1<<20;
 
int mult(int a, int b) {//乘法取模函数
    return (1LL * a * b) % mod;
}
 
int pw(int a, int b) {//快速幂
    if (b == 0) return 1;
    if (b & 1) return mult(a, pw(a, b - 1));
    int res = pw(a, b / 2);
    return mult(res, res);
}
 
int sub(int a, int b) {//减法取模函数
    int s = a - b;
    if (s < 0) s += mod;
    return s;
}
 
int sum(int a, int b) {加法取模函数
    int s = a + b;
    if (s >= mod) s -= mod;
    return s;
}
 
const int maxN = 2 * (int)1e5 + 100;//数据范围
 
int fact[maxN], invfact[maxN], inv[maxN];
 
void init() {
    inv[1] = invfact[1] = invfact[0] = fact[0] = fact[1] = 1;
    for (int i = 2; i < maxN; i++) {
        fact[i] = mult(fact[i - 1], i);
        inv[i] = mult(inv[mod % i], mod - mod / i);
        invfact[i] = mult(invfact[i - 1], inv[i]);
    }
}
 
int cnk(int n, int k) {//算组合数
    if (n < k) return 0;
    if (n < 0 || k < 0) return 0;
    return mult(fact[n], mult(invfact[k], invfact[n - k]));
}
 
int invNumber(int a) {
    return pw(a, mod - 2);
}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    init();//清空数组
    int n, m;
    cin >> n >> m;
    if (n == 2) {
        cout << 0;
        return 0;
    }
    cout << mult(pw(2, n - 3), mult(cnk(m, n - 1), n - 2));//乘法取模操作、快速幂操作、求组合数操作
    return 0;
}
============================
字符串哈希：
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ULL;
const int N = 1e6 + 10;
const int base = 131;

char str[N];
ULL h[N], p[N];

ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    scanf("%s", str + 1);
    int n = strlen(str + 1);
    p[0] = 1;
    for (int i = 1; i <= n; i++)//将小写字母映射到数字上
    {
        h[i] = h[i - 1] * base + str[i] - 'a' + 1;
        p[i] = p[i - 1] * base;
    }
    int T;
    cin >> T;
    while (T--)
    {
        int l, r;
        cin >> l >> r;
        cout << get(l, r) << endl;
    }
}
===============================
矩阵快速幂：(集训队版)
const int N=200;
const int mode=9973;
struct Matrix{
	int n,m;
	int v[N][N];
	Matrix(int n,int m):n(n),m(m){}
	void init(){     //初始化矩阵 
		memset(v,0,sizeof(v));
	}
	Matrix operator* (const Matrix B) const {
	Matrix C(n,B.m);   //用来存放答案
	C.init();
	for(int i=0;i<n;i++)
	for(int j=0;j<B.m;j++)
	for(int k=0;k<m;k++)
		C.v[i][j] += v[i][k]*B.v[k][j];
	return C;	
	}
};
Matrix qpow(Matrix a,int x){
	Matrix ret(a.n,a.m);
 	ret.init();
	for(int i=0;i<a.n;++i) ret.v[i][i]=1;//初始化为单位矩阵
	while(x){
		if(x&1) ret=ret*a;
		a=a*a;
		x>>=1;
	} 
	return ret;
}
int main(){
	int t;cin >> t;
	while(t--){
		int n;scanf("%d",&n);
		Matrix A(n,n);A.init();
		int k;scanf("%d",&k);
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++){
				scanf("%d",&A.v[i][j]);
			}
		}
		A=qpow(A,k);//算A的k次方
		int ans=0;
		for(int i=0;i<n;i++){
			ans=(ans+A.v[i][i])%mode;//算矩阵的迹 
		} 
		printf("%d\n",ans);
	}
}
==========================
矩阵快速幂2：(功能不全但好用)
const int mode = 9973;
int n;
const int N=11;
struct matrix
{
    int mat[N][N];
    matrix operator*(const matrix m) const
    {
        matrix tmp;
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
            {
                tmp.mat[i][j] = 0;
                for (int k = 0; k < n; k++)
                {
                    tmp.mat[i][j] += mat[i][k] * m.mat[k][j] % mode;
                    tmp.mat[i][j] %= mode;
                }
            }
        return tmp;
    }
};
long long qpow(matrix &m, int k)
{
    matrix ans;
    memset(ans.mat, 0, sizeof(ans.mat));
    for (int i = 0; i < n; i++)
        ans.mat[i][i] = 1;
    while (k)
    {
        if (k & 1)
            ans = ans * m;
        k >>= 1;
        m = m * m;
    }                           //平时return ans即可
    /*long long sum = 0;
    for (int i = 0; i < n; i++)//算矩阵的迹（就是主对角线上各项的和）
    {
        sum += ans.mat[i][i] % mode;
        sum %= mode;
    }
    return sum;*/
}
int main()
{
    IOS;
    matrix cat;
    int T;
    ll k;
    cin >> T;
    while (T--)
    {
        cin >> n >> k;
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                cin >> cat.mat[i][j];
            }
        }
        cout << qpow(cat, k) << endl;//输出矩阵的迹
    }
}
======================
矩阵快速幂3：（同学版本）
const ll mode=9973;
const ll N=15;
struct matrix{
	ll n,m;
	ll mat[N][N];
};
void init(matrix &a,ll n);
matrix m_qpow(matrix a,ll k);
matrix muti(matrix a,matrix b);
matrix m_qpow(matrix a,ll k){
	matrix ans;
	init(ans,a.n);
	while(k){
		if(k&1)ans=muti(ans,a);
		a=muti(a,a);
		k>>=1;
	}
	return ans;
}
void init(matrix &a, ll n){//初始化方阵; 不是方阵请稍微修改 
	a.n=a.m=n;//修改这里 
	memset(a.mat,0,sizeof(a.mat));
	for(ll i=1;i<=n;++i){//还有这里 
		a.mat[i][i]=1;
	}
}
matrix muti(matrix a,matrix b){
	matrix ans;
	ans.n=a.n;
	ans.m=b.m;
	memset(ans.mat,0,sizeof(ans.mat));
	for(ll i=1;i<=a.n;i++){
		for(ll j=1;j<=a.m;j++){
			for(ll k=1;k<=a.m;k++){
				ans.mat[i][j]=
					(ans.mat[i][j]+a.mat[i][k]*b.mat[k][j])%mode;
			}
		}
	}
	return ans;
}
int main(){
	ll t;
	cin >> t;
	while(t--){
		ll n,k;
		cin >> n >> k;
		matrix a;
		init(a,n);
		for(int i=1;i<=n;i++){
			for(itn j=1;j<=n;j++){
				cin >> a.mat[i][j];
			}
		}
		matrix ans=m_qpow(a,k);
		ll sum=0;
		for(int i=1;i<=n;i++)sum+=ans.mat[i][i];
		cout<<sum%mode<<endl;
	}
}
============================
矩阵快速幂4（完全版）（巨好用！！！）
#define NUM 50//数据范围
int k,n,m;
struct Matrix
{
	int a[NUM][NUM];
	void init()           
	{
		memset(a,0,sizeof(a));
		for(int i=0;i<n;i++)
			a[i][i]=1;
	}
} A;
Matrix mul(Matrix a,Matrix b)  //矩阵普通乘法
{
	Matrix ans;
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
		{
			ans.a[i][j]=0;
			for(int k=0;k<n;k++)
				ans.a[i][j]+=a.a[i][k]*b.a[k][j];
			ans.a[i][j]%=m;
		}
	return ans;
}

Matrix add(Matrix a,Matrix b)  //矩阵加法
{
	int i,j,k;
	Matrix ans;
	for(i=0;i<n;i++)
		for(j=0;j<n;j++)
		{
			ans.a[i][j]=a.a[i][j]+b.a[i][j];
			ans.a[i][j]%=m;
		}
	return ans;
}

Matrix qpow(Matrix a,int n) //矩阵快速幂
{
	Matrix ans;
	ans.init();
	while(n)
	{
		if(n%2)
			ans=mul(ans,a);
		n/=2;
		a=mul(a,a);
	}
	return ans;
}

Matrix sum(Matrix a,int n)   //算 A + A^2 + A^3 + … + A^k.
{
	int m;
	Matrix ans,pre;
	if(n==1)
		return a;
	m=n/2;
	pre=sum(a,m);                     
	ans=add(pre,mul(pre,pow(a,m)));   
	if(n&1)
		ans=add(ans,pow(a,n));          
	return ans;
}
int main()
{
	Matrix ans;
	scanf("%d%d%d",&n,&k,&m);
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
		{
			scanf("%d",&A.a[i][j]);
			A.a[i][j]%=m;
		}
	ans=sum(A,k);
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			printf("%d%c",ans.a[i][j],j==n-1?'\n':' ');
	return 0;
}
=============
二叉树建树、层序遍历、判断是否为完全二叉树模板：
（下面代码是标准的建树过程，可以拿来直接使用（注意本题要求是左大右小，但正常是左小右大））
如需修改左小右大  请改Inset_BST函数
#include <bits/stdc++.h>
 
using namespace std;
int N;
bool flag=false;
 
 
typedef struct node
{
    node()
    {
        data=0;
        l=NULL;
        r=NULL;
    }
    node(int a,node* b,node* c)
    {
        data=a;
        l=b;
        r=c;
    }
    int data;
    struct node *l;
    struct node *r;
}*BST;
 
 
 
void FloorPrint_oeder(BST T)
{
    int l=0,r=0;
    BST a[10000];
    a[r++]=T;
 
    bool flag1=true;
    int pd=1;
 
    while(l!=r)
    {
        BST t=a[l++];
        if(flag1)
        {
            printf("%d",t->data);
            flag1=false;
        }
        else printf(" %d",t->data);
 
        if(t->l!=NULL)
        {
            a[r++]=t->l;
            pd*=-1;
        }
        if(t->r!=NULL)
        {
            a[r++]=t->r;
            pd*=-1;
        }
    }
 
}
 
 
bool judge_wq(BST T)
{
    bool flag=true;
    int l=0,r=0;
    BST a[1000];
    a[r++]=T;
 
    while(l!=r)
    {
        BST t=a[l++];
 
 
        if(t->l!=NULL&&t->r!=NULL)
        {
            if(flag)
            {
 
                a[r++]=t->l;
                a[r++]=t->r;
            }
            else return false;
        }
        else if(t->l!=NULL&&t->r==NULL)
        {
            if(flag)
            {
 
                a[r++]=t->l;
                flag=false;
            }
            else return false;
        }
        else if(t->l==NULL&&t->r!=NULL)  return false;
        else if(t->l==NULL&&t->r==NULL) flag=false;
 
    }
 
    return true;
}
 
 
void Inset_BST(BST &T,int data)
{
    if(T==NULL)
    {
        T=new node(data,NULL,NULL);
    }
    else if(T->data < data)
    {
        Inset_BST(T->l,data);
    }
    else Inset_BST(T->r,data);
}
 
 
 
int main()
{
 
    scanf("%d",&N);
    BST tree=NULL;
    for(int i=0; i<N; i++)
    {
        int t;
        scanf("%d",&t);
        Inset_BST(tree,t);
    }
 
    FloorPrint_oeder(tree);
 
    if(judge_wq(tree)) printf("\nYES\n");
    else printf("\nNO\n");
 
 
    return 0;
 
}
马拉车：
先上压缩代码比赛用：
namespace Manacher{
    vector<int> ans, str, lef;
    int build(const string &s){
        int n = s.length(), m = (n + 1) << 1, ret = 0;
        str.resize(m + 1); ans.resize(m + 1); lef.resize(m + 1);
        str[0] = '$'; str[m] = '@'; str[1] = '#'; ans[1] = 1;
        for (int i = 1; i <= n; i++) str[i << 1] = s[i - 1], str[i << 1 | 1] = '#';
        for (int r = 0, p = 0, i = 2; i < m; ret = max(ret, ans[i++] - 1)){
            for (ans[i] = r > i ? min(r - i, ans[p * 2 - i]) : 1; str[i - ans[i]] == str[i + ans[i]]; ++ans[i]);
            if (i + ans[i] > r) r = i + ans[i], p = i;
        }
        for (int i = 0; i <= m; i++) lef[i] = 0;
        for (int i = 2; i < m; i++) if (lef[i - ans[i] + 1] < i + 1) lef[i - ans[i] + 1] = i + 1;
        for (int i = 1; i <= m; i++) if (lef[i] < lef[i - 1]) lef[i] = lef[i - 1];
        return ret;
    }
    int mid(int x, bool odd){
        if (odd) return ans[(x + 1) << 1] - 1;
        return ans[(x + 1) << 1 | 1] - 1;
    }
    int left(int x){ return lef[(x + 1) << 1] - ((x+1) << 1); }
}
-------------
原始代码：
namespace Manacher{
    vector<int> ans, str, lef;
    int build(const string &s){
        // 初始化
        int n = s.length(), m = (n + 1) << 1, ret = 0;
        str.resize(m + 1); ans.resize(m + 1); lef.resize(m + 1);
        // $ - 串开始标记， @ - 串结束标记，# - 将字母间隔开。注意这里的字符必须是字符串内不存在的
        str[0] = '$'; str[m] = '@'; str[1] = '#'; ans[1] = 1;
        for (int i = 1; i <= n; i++) 
            str[i << 1] = s[i - 1], str[i << 1 | 1] = '#';
        // Manacher 操作。r, p 分别维护当前最靠右最长回文串的右边界与中心
        ans[1] = 1;
        for (int r = 0, p = 0, i = 2; i < m; ++i){
            if (r > i) ans[i] = min(r - i, ans[p * 2 - i]); else ans[i] = 1; // Manacher 核心操作
            while(str[i - ans[i]] == str[i + ans[i]]) ++ans[i]; // 暴力向外扩展
            if (i + ans[i] > r) r = i + ans[i], p = i; // 尝试更新 r, p
            ret = max(ret, ans[i] - 1); // 更新答案
        }
        // 计算维护以每个位置为起点的最长回文串
        for (int i = 0; i <= m; i++) lef[i] = 0;
        for (int i = 2; i < m; i++) if (lef[i - ans[i] + 1] < i + 1) lef[i - ans[i] + 1] = i + 1;
        for (int i = 1; i <= m; i++) if (lef[i] < lef[i - 1]) lef[i] = lef[i - 1];
        return ret;
    }
    int mid(int x, bool odd){//x是原串的下标，查询以x为中点的最长回文子串的长度，odd是 查询奇回文子串(odd=1)还是偶回文子串(0)
        if (odd) return ans[(x + 1) << 1] - 1;
        return ans[(x + 1) << 1 | 1] - 1;
    }
    int left(int x){ return lef[(x + 1) << 1] - ((x+1) << 1); }//查询以x为起点的最长回文子串的长度
}
=====================
n皇后方案数：//打表版：const LL a[] = {-1,1,0,0,2,10,4,40,92,352,724,2680,14200,73712,36559};  n皇后就a[n]
#include"bits/stdc++.h"
using namespace std;
typedef long long LL;
LL dfs(LL END,LL sta,LL ld,LL rd)
{
    if(sta==END)return 1;
    else if(sta>END)return 0;
    LL pos=(END)&(~(sta|ld|rd));
    LL ans=0; 
    while(pos)
    {
        LL t=pos&-pos;
        ans+=dfs(END,sta|t,(ld|t)<<1,(rd|t)>>1);
        pos-=t;
    }
    return ans;
}
int main()
{
    LL N;
    while(cin>>N)
    {
        cout<<dfs((1<<N)-1,0,0,0)<<endl;
    }
}
=======================
求x的阶乘在k进制下末尾0的个数：
#include<iostream>
#include<cstdio>   
#include<cmath>   
#define N 3000001   
using namespace std;
long long a[N],b[N];//a数组存k的质因子，b数组存k的某质因子的个数 
long long sum;   
long long n,k; 
long long ans=0x7fffffffffffffff,temp;    
void fenjie(long long s)  //求质因子及个数 （大概不需要解释了吧。。。） 
{    
    long long i,j=0;   
    for (i=2;i*i<=s;i++)   
        if (s%i==0)   
        {   
            long long count=0;   
            a[j]=i;   
            while (s%i==0)   
            {   
                count++;   
                s/=i;   
            }   
            b[j++]=count;   
        }   
    if (s>1)   
    {    
        a[j]=s;   
        b[j++]=1;   
    }   //可能容易遗漏，即k本身是质数 
    sum=j;   
}   
   
long long fac(long long x,long long y)   
{   
    if (x<y)   
        return 0;  //判断x是否小于y，若小于，结束统计(否则会一直做下去) 
    else   
        return x/y+fac(x/y,y); //统计n！中a[i]出现的次数 
}   
   
int main()   
{   
    while (scanf("%lld%lld",&n,&k)==2)  //多组数据嘿嘿嘿（反正有人因为这个没分） 
    {   
        fenjie(k);  
        for(int i=0;i<sum;i++)  
        {  
            temp=fac(n,a[i]); 
            temp/=b[i];  //注意，k可以分解为多个a[i]，所以temp还要再除以a[i]的个数 
            ans=ans>temp?temp:ans;   
        }  
        printf("%lld\n",ans);  
    }   
    return 0;   
}
===========================
判断x是否为斐波那契数列里面的数：
LL f[101];
bool flag = 0;
    f[1] = f[2] = 1;
    for (LL i = 3; i <= 100; i++)
        f[i] = f[i - 1] + f[i - 2];
    for (LL i = 1; i <= 80; i++)
        if (f[i] == x)
            flag = 1;//如果flag是1  那x是斐波那契数。
=============================
判断数组中，有没有几个数相加等于3600的倍数（3600可改）：
inline int read(){
    int x=0,f=1;char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0';
    return x*f;
}
const int MAXN = 200010;
 
int N,a[MAXN+1]; bitset<7201> now,tmp,ttmp;
 
inline void solve(){
    N=read();
    for(int i=1;i<=N;i++) a[i]=read()%3600;
    now.reset(); now[0]=1;
    for(int i=1;i<=N;i++){
        tmp=ttmp=(now<<a[i]); tmp>>=3600;
        now|=tmp; now|=ttmp;
    } printf(now[3600]?"YES\n":"NO\n");
}
=============================
大数加法模板：
string add(string a, string b){
    string c;
    if(a.size() > b.size()) swap(a, b);
    int len = min(a.size(), b.size());
    int f = 0;
    for(int i = len - 1, j = b.size() - 1; i >= 0; i--, j--){
        c += ((a[i] - '0' + b[j] - '0' + f) % 10) + '0';
        f = (a[i] - '0' + b[j] - '0' + f) / 10;
    }
    for(int j = b.size() - a.size() - 1; j >= 0; j--){
        c += ((b[j] - '0' + f) % 10) + '0';
        f = (b[j] - '0' + f) / 10;
    }
    if(f){
        c += '1';
    }
    reverse(c.begin(), c.end());
    return c;
}
=========================
给定年月日计算是周几：
int ReturnWeekDay( unsigned int iYear, unsigned int iMonth, unsigned int iDay )
{
	int iWeek = 0;
	unsigned int y = 0, c = 0, m = 0, d = 0;
 
	if ( iMonth == 1 || iMonth == 2 )
	{
		c = ( iYear - 1 ) / 100;
		y = ( iYear - 1 ) % 100;
		m = iMonth + 12;
		d = iDay;
	}
	else
	{
		c = iYear / 100;
		y = iYear % 100;
		m = iMonth;
		d = iDay;
	}
	
	iWeek = y + y / 4 + c / 4 - 2 * c + 26 * ( m + 1 ) / 10 + d - 1;    //蔡勒公式
	iWeek = iWeek >= 0 ? ( iWeek % 7 ) : ( iWeek % 7 + 7 );    //iWeek为负时取模
	if ( iWeek == 0 )    //星期日不作为一周的第一天
	{
		iWeek = 7;
	}
 
	return iWeek;
}
===========================
计算两个日期相差多少天：
#include <iostream>
#include <string>
#include <cmath>

using namespace std;

struct Date{
 int y;//year
 int m;//month
 int d;//day in month
};

int isLeap(int y)
{
 return y%4==0 && y%100==0 || y%400==0;
}

int daysOfMonth(Date d)
{
 int days[12]={31,0,31,30,31,30,31,31,30,31,30,31};
 if(d.m!=2)
  return days[d.m-1];
 else
  return 28+isLeap(d.y);
}

int daysOfDate(Date d)
{
 int days=0;
 for(int y=1;y<=d.y;y++)
  days+=365+isLeap(y);
 for(int m=1;m<d.m;m++)
  days+=daysOfMonth(d);
 days+=d.d;
 return days;
}

int main()
{
 int a;
 Date d1,d2;
    cout << "Input 2 days days(yyyy mm dd):" << endl;
    cin >> d1.y >> d1.m >> d1.d ;
 cout << d1.y << "-" << d1.m << "-" << d1.d << endl;
 int days1=daysOfDate(d1);
    cout << "days1=" << days1 << endl;
 cin >> d2.y >> d2.m >> d2.d ;
 cout << d2.y << "-" << d2.m << "-" << d2.d << endl;
 int days2=daysOfDate(d2);
    cout << "days2=" << days2 << endl;
    cout << "days distance is " << fabs(days1- days2) << endl;

 return 0;
}
=======================
unique加erase去重：
vec.erase(unique(vec.begin(),vec.end()),vec.end());
========================
地图类二维bfs模板：（HDU1242）
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<queue>
using namespace std;
#define INF 0x3f3f3f3f
char a[205][205];//0.变量设置，地图数组变量，vis变量，方向变量，起始位置变量
bool vis[205][205];
int dire[4][2] = { { 1,0 },{ 0,1 },{ -1,0 },{ 0,-1 } };
int rx, ry;
int ans;

struct Node//6.设置节点结构体
{
    int x, y;
    int cnt;
    friend bool operator<(Node a, Node b)
    {
        return a.cnt>b.cnt;
    }
}sc, now;

void findR(int n, int m)//4.获得开始位置
{
    for (int i = 1; i < n; i++)
    {
        for (int j = 1; j < m; j++)
        {
            if (a[i][j] == 'r')
            {
                rx = i;
                ry = j;
                return;
            }
        }
    }
}

void bfs()
{
    priority_queue<Node>q;//7.设置队列（或优先队列）

    sc.x = rx;//8.第一个节点的push
    sc.y = ry;
    sc.cnt = 0;
    q.push(sc);
    while (q.size())//9.while
    {
        now = q.top();//10.获得top（）
        q.pop();//11.pop（）；
        if (a[now.x][now.y] == 'a')//12.BFS终点判断
        {
            ans = now.cnt;
            return;
        }
        for (int i = 0; i < 4; i++)//13.遍历方向
        {
            int nowx = now.x + dire[i][0], nowy = now.y + dire[i][1];//14.获得当前xy
            if (!vis[nowx][nowy] && a[nowx][nowy] != '#')//15.没访问过&&不是墙（依据题目加条件）
            {
                vis[nowx][nowy] = 1;//16.vis置1
                sc.x = nowx;//17.更新sc结构体所有属性
                sc.y = nowy;
                if (a[nowx][nowy] == 'x')sc.cnt = now.cnt + 2;
                else sc.cnt = now.cnt + 1;
                q.push(sc);//18.push（）
            }
        }
    }
}

int main()
{
    int n, m;
    while (cin >> n >> m)//1.输入
    {
        memset(a, '#', sizeof(a));//2.初始化设置墙体
        memset(vis, 0, sizeof(vis));//3.初始化vis数组
        for (int i = 1; i <= n; i++)
        {
            scanf("%s", a[i] + 1);
        }
        for (int i = 1; i <= n; i++)
        {
            a[i][m + 1] = '#';
        }
        findR(n, m);//4.获得开始位置
        ans = INF;
        bfs();//5.BFS
        if (ans != INF)printf("%d\n", ans);//最后输出
        else printf("Poor ANGEL has to stay in the prison all his life.\n");
    }
}
---------------------------------------------------------------------------------------------------
地图类三维bfs模板：（例题：https://ac.nowcoder.com/acm/contest/5338/A）
#include <bits/stdc++.h>
 
using namespace std;
 
const int N = 110;
 
int n;
char m[N][N][N];
int dis[N][N][N];
 
typedef struct Edge
{
    int third;
    int second;
    int first;
}three;
 
int bfs()
{
    queue<three> q;
    memset(dis, -1, sizeof dis);
    q.push({1, 1, 1});
    dis[1][1][1] = 1;
    int dx[] = {0, 1, 0, -1 ,0 , 0}, dy[] = {1, 0, -1, 0, 0, 0}, dz[] = {0, 0, 0, 0, 1, -1};
    while(q.size())
    {
        three t = q.front();
        q.pop();
        for(int i = 0; i < 6; i++)
        {
            int x = t.third + dx[i], y = t.second + dy[i], z = t.first + dz[i];
            if(x >= 1 && y >= 1 && z >= 1 && x <= n && y <= n && z <= n && dis[x][y][z] == -1 && m[x][y][z] != '*')
            {
                dis[x][y][z] = dis[t.third][t.second][t.first] + 1;
                q.push({x, y, z});
            }
        }
    }
 
    return dis[n][n][n];
}
 
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            for(int k = 1; k <= n; k++)
                cin >> m[i][j][k];
 
    auto t = bfs();
    if(t == -1)
        cout << -1 << endl;
    else
        cout << t << endl;
 
    return 0;
}
==============================
划分数：
#include<cstdio>  
#include<cstring>
#include<iostream>
using namespace std;

int dp[1010][1010];

int main()  {  
  int n,m,mod;
  cin >> n >> m >> mod;
  
  
  for(int i = 1;i <= m; i++){
      for(int j = 0;j <= n; j++){
          if(j - i >= 0){
              dp[i][j] = (dp[i-1][j] + dp[i][j-i])%mod;
          }else{
              dp[i][j] = dp[i-1][j];
            }
        }
    }
    
    cout << dp[m][n] << endl;
  return 0;  
} 
==============================
多重集组合数：
#include <cstdio>
#include <cmath>
#include <cstring>
#include <string>
#include <algorithm>
#include <iostream>
#include <queue>
#include <map>
#include <set>
#include <vector>
using namespace std;
int n, m;
int a[1005];

int dp[1005][1005];

int main()
{
    while (cin >> n >> m)
    {
        for (int i = 0; i < n; i++)
        {
            cin >> a[i];
        }
        int M;

        cin >> M;
        for (int i = 0; i <= n; i++)
        {
            dp[i][0] = 1;
        }
        for (int i = 0; i < n; i++)
        {
            for (int j = 1; j <= m; j++)
            {
                if (j > a[i])
                    dp[i + 1][j] = (dp[i][j] + dp[i + 1][j - 1] - dp[i][j - 1 - a[i]] + M) % M;
                //此处+M是防止减法操作得到一个负数， 加一个M不影响结果并保证了答案不为负数。
                else
                {
                    dp[i + 1][j] = dp[i][j] + dp[i + 1][j - 1];
                }
            }
        }
        printf("%d\n", dp[n][m]);
    }
    return 0;
}
============================
tarjan强连通模板题：洛谷P2341：
#include<bits/stdc++.h>
#define ri register int
using namespace std;
const int maxn=1e4+5;
const int maxm=5e4+5;
int to[maxm],nex[maxm],fir[maxn];
int col,num,dfn[maxn],low[maxn],de[maxn],si[maxn];
int tot=0,co[maxn],n,m;
int top,st[maxn];
template<class T> inline void read(T &x)
{
    x=0;
    register char c=getchar();
    register bool f=0;
    while (!isdigit(c)) f ^=c=='-',c=getchar();
 	while (isdigit(c)) x=x*10+c-'0',c=getchar();
    if(f)x=-x;
}
template <class T> inline void print(T x)
{
    if(x<0)putchar('-'),x=-x;
    if(x>9)print(x/10);
    putchar('0'+x%10);
}
inline void ins(int x,int y)
{
    to[++tot]=y;
    nex[tot]=fir[x];
    fir[x]=tot;
}
void Tarjan(int u)
{
    dfn[u]=low[u]=++num;
    st[++top]=u;
    for(int i=fir[u];i;i=nex[i])
    {
        int v=to[i];
        if(!dfn[v])
        {
            Tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else if(!co[v])low[u]=min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u])
    {
        co[u]=++col;
        ++si[col];
        while(st[top]!=u)
        {
            ++si[col];
            co[st[top]]=col;
            --top;
        }
        --top;
    }
}
int main()
{
    int x,y;
    read(n);read(m);
    for(ri i=1;i<=m;i++)
    {
        read(x);read(y);
        ins(y,x);
    }
    for(ri i=1;i<=n;i++)
        if(!dfn[i])Tarjan(i);
    for(ri i=1;i<=n;i++)
        for(ri j=fir[i];j;j=nex[j])
            if(co[i]!=co[to[j]])de[co[to[j]]]++;
    int ans=0,u=0;
    for(ri i=1;i<=col;i++)if(!de[i])ans=si[i],u++;
    if(u==1)print(ans);
     else print(0);
 	return 0;
}